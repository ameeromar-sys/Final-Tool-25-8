<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مترجم الأسئلة المحترف (مع محرر رياضي متكامل)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- MathLive for LaTeX editing -->
    <script src="https://unpkg.com/@nagwa-limited/mathlive" defer></script>
    <!-- Fabric.js for simple image annotation/editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- Diff Match Patch for comparing text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --highlight-bg: #fef9c3;
            --diff-ins-bg: #ddfbe9;
            --diff-del-bg: #fce8e9;
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --highlight-bg: #4d4318;
            --diff-ins-bg: #133825;
            --diff-del-bg: #411a1d;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .main-card,
        .preview-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input,
        select,
        textarea {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
        }

        .dragover {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color));
        }

        .api-selector input[type="radio"]:checked+label {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
            color: var(--primary-color);
        }

        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }

        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }

        .search-highlight,
        mark.search-highlight {
            background-color: var(--highlight-bg);
            color: var(--text-color);
            border-radius: 3px;
            padding: 0 2px;
        }

        #saveIndicator {
            font-size: 0.85rem;
            color: var(--secondary-text);
        }

        #saveIndicator.saved {
            color: var(--success-color);
        }

        #saveIndicator.error {
            color: var(--error-color);
        }

        /* Accordion Styles */
        .accordion-header {
            width: 100%;
            padding: 1rem 1.5rem;
            text-align: right;
            font-weight: 700;
            font-size: 1.125rem;
            border-radius: 0.75rem;
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .accordion-header:hover {
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            background-color: var(--card-bg);
            border-top: 1px solid var(--card-border);
        }

        .accordion-content.open {
            padding: 1.5rem;
        }

        /* Diff View Styles */
        .diff-view {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--card-border);
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
        }

        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: line-through;
        }

        /* Status Indicator */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }

        .status-translated {
            background-color: var(--success-color);
        }

        .status-edited {
            background-color: #f59e0b;
        }

        /* Amber 500 */

        /* Styles for MathLive Fields */
        .editable-preview-field {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            min-height: 80px;
        }

        math-field {
            position: relative;
        }

        .math-field-delete-btn {
            position: absolute;
            top: -10px;
            left: -10px; /* Position it at the top-left corner */
            background-color: var(--error-color);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        math-field:hover .math-field-delete-btn,
        math-field:focus-within .math-field-delete-btn {
            opacity: 1;
            visibility: visible;
        }
        /* MathLive default look (editable) */
        math-field {
            border: 1px solid var(--input-border);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 1.1em;
            display: inline-block;
            background: var(--input-bg);
            min-width: 20px;
            margin: 2px;
            max-width: 100%;
            white-space: nowrap;
        }

        /* Higher-fidelity preview to match source system: make formulas look inline and unboxed inside preview */
        .editable-preview-field math-field {
            border: 0;
            background: transparent;
            padding: 0 2px;
            box-shadow: none;
        }

        .editable-preview-field .content-root {
            line-height: 1.8;
        }

        .editable-preview-field .content-root p {
            margin: .25rem 0;
        }

        /* Approximate Lexical theme blocks so content spacing matches original */
        .LexicalTheme__paragraph {
            white-space: pre-wrap;
            margin: .25rem 0;
        }

        .LexicalTheme__image img {
            max-width: 100%;
            height: auto;
        }

        math-field:focus-within {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--input-bg));
            box-shadow: 0 0 0 2px var(--primary-color);
            outline: none;
        }

        /* Enhanced MathLive keyboard styling for Arabic support */
        math-field {
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Arabic text in math fields */
        math-field[dir="rtl"] {
            text-align: right;
            direction: rtl;
        }

        /* English text in math fields */
        math-field[dir="ltr"] {
            text-align: left;
            direction: ltr;
        }

        /* Mixed content in math fields */
        math-field[dir="auto"] {
            text-align: start;
            direction: auto;
        }

        /* Virtual keyboard styling */
        .ML__keyboard {
            font-family: 'Cairo', 'Arial', sans-serif !important;
        }

        /* Arabic keys in keyboard */
        .ML__keyboard .ML__key[data-key*="\u0600"] {
            font-family: 'Cairo', 'Arial', sans-serif !important;
            font-size: 1.1em;
        }

        /* Language indicator */
        .ML__keyboard::before {
            content: attr(data-language);
            position: absolute;
            top: -25px;
            left: 10px;
            font-size: 12px;
            color: var(--secondary-text);
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Enhanced keyboard theme for Arabic */
        .ML__keyboard[data-language="ar"] {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        /* Arabic key styling */
        .ML__keyboard[data-language="ar"] .ML__key {
            border-radius: 6px;
            border: 1px solid #dee2e6;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .ML__keyboard[data-language="ar"] .ML__key:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .ML__keyboard[data-language="ar"] .ML__key:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Visual blank for underscores in preview (does not persist to JSON) */
        .blank-slot {
            display: inline-block;
            min-width: 1.8em;
            border-bottom: 2px solid currentColor;
            vertical-align: baseline;
            line-height: 1.2;
            margin: 0 0.15em;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
            padding: 1px 2px;
        }

        /* Ensure blanks are visible in both original and translated text */
        .original-text-readonly .blank-slot,
        .editable-preview-field .blank-slot {
            border-bottom: 2px solid #666;
            background-color: rgba(0, 0, 0, 0.08);
        }

        /* Make blanks more prominent in original text */
        .original-text-readonly .blank-slot {
            border-bottom: 3px solid #333;
            background-color: rgba(0, 0, 0, 0.12);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are visible in read-only fields */
        .p-3.rounded-lg.text-sm .blank-slot {
            border-bottom: 2px solid #555;
            background-color: rgba(0, 0, 0, 0.1);
            min-width: 2em;
        }

        /* Make blanks more visible in different contexts */
        .blank-slot {
            position: relative;
            cursor: default;
        }

        .blank-slot::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        /* Add hover effect to make blanks more interactive */
        .blank-slot:hover {
            background-color: rgba(0, 0, 0, 0.15) !important;
            border-bottom-color: #333 !important;
        }

        /* Ensure blanks are visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot {
                background-color: rgba(255, 255, 255, 0.1) !important;
                border-bottom-color: #ccc !important;
            }

            .blank-slot:hover {
                background-color: rgba(255, 255, 255, 0.2) !important;
                border-bottom-color: #fff !important;
            }
        }

        /* Add tooltip to show blank length on hover */
        .blank-slot[data-blank]:hover::before {
            content: attr(data-blank);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Ensure tooltip is visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot[data-blank]:hover::before {
                background-color: #fff;
                color: #333;
            }
        }

        /* Add animation for better visual feedback */
        .blank-slot {
            transition: all 0.2s ease-in-out;
        }

        .blank-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are accessible */
        .blank-slot[data-blank] {
            aria-label: "فراغ: " attr(data-blank);
        }

        /* Add focus styles for keyboard navigation */
        .blank-slot:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Ensure blanks are visible in print */
        @media print {
            .blank-slot {
                border-bottom: 2px solid #000 !important;
                background-color: transparent !important;
                box-shadow: none !important;
            }
        }

        /* Add support for high contrast mode */
        @media (prefers-contrast: high) {
            .blank-slot {
                border-bottom: 3px solid #000 !important;
                background-color: #fff !important;
            }
        }

        /* Add support for reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                transition: none !important;
            }

            .blank-slot:hover {
                transform: none !important;
            }
        }

        /* Advanced text direction support for mixed content */
        .text-mixed {
            direction: auto;
            text-align: start;
            unicode-bidi: embed;
        }

        /* Enhanced text direction for Arabic-English mixed content */
        .rtl-auto {
            direction: rtl;
            text-align: right;
            unicode-bidi: embed;
        }

        .ltr-auto {
            direction: ltr;
            text-align: left;
            unicode-bidi: embed;
        }

        /* Support for inline mixed text */
        .mixed-content {
            direction: auto;
            unicode-bidi: plaintext;
        }

        /* Improved support for numbers in Arabic text */
        .arabic-numerals {
            font-family: 'Arial Unicode MS', Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        .english-numerals {
            font-family: Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Enhanced preview content direction */
        .original-text-readonly,
        .editable-preview-field {
            direction: auto;
            text-align: start;
            unicode-bidi: plaintext;
        }

        /* Special handling for mixed content in preview */
        .content-root {
            direction: rtl;
            text-align: right;
            unicode-bidi: bidi-override;
        }

        .content-root * {
            unicode-bidi: embed;
        }

        /* Handle English phrases within Arabic text */
        .english-phrase {
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Handle Arabic phrases within English text */
        .arabic-phrase {
            direction: rtl;
            unicode-bidi: embed;
            display: inline;
        }

        /* Math and chemical formulas should always be LTR */
        math-field,
        .math-content,
        .chemical-formula {
            direction: ltr !important;
            unicode-bidi: embed;
            text-align: left;
        }

        /* Improved blank slots for mixed content */
        .blank-slot {
            direction: inherit;
            unicode-bidi: embed;
        }

        /* Add support for large text */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                min-width: 2.5em;
                font-size: 1.1em;
            }
        }

        /* Tables inside editable preview */
        .editable-preview-field table {
            width: 100%;
            border-collapse: collapse;
            direction: rtl;
        }

        .editable-preview-field th,
        .editable-preview-field td {
            border: 1px solid var(--card-border);
            padding: 6px 8px;
            vertical-align: top;
        }

        .editable-preview-field thead {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
        }

        /* Make table cells editable */
        .editable-preview-field td,
        .editable-preview-field th {
            position: relative;
            min-height: 1.5em;
            cursor: text;
        }

        .editable-preview-field td:focus,
        .editable-preview-field th:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: color-mix(in srgb, var(--primary-color) 5%, var(--input-bg));
        }
    </style>
</head>

<body class="text-gray-800">
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">🌍 مترجم الأسئلة المحترف
            </h1>
            <div class="flex items-center gap-4">
                <span id="saveIndicator" aria-live="polite">—</span>
                <button id="theme-toggle" class="text-2xl">☀️</button>
                <button id="newSessionBtn"
                    class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">بدء
                    جلسة جديدة</button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ترجمة ملفات JSON، مع المعاينة
            والتعديل، ودعم المعادلات الرياضية.</p>

        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2"
                style="color: var(--primary-color); border-color: var(--primary-color-light);">الخطوة 1: الإعدادات ورفع
                الملفات</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">اختر مُزوّد الخدمة:</label>
                        <div class="api-selector grid grid-cols-3 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden"
                                    checked>
                                <label for="geminiProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">🤖 Gemini</span></label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt"
                                    class="hidden">
                                <label for="chatgptProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">💬 ChatGPT</span></label>
                            </div>
                            <div>
                                <input type="radio" id="localModelProvider" name="apiProvider" value="local"
                                    class="hidden">
                                <label for="localModelProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">🖥️ نموذج محلي</span></label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">مفتاح Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="يبدأ بـ AIza..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">مفتاح OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="يبدأ بـ sk-..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="localModelGroup" class="mb-6 hidden">
                        <label for="localModelUrl" class="block mb-2 font-semibold">عنوان URL لخادم Ollama:</label>
                        <input type="text" id="localModelUrl" placeholder="http://localhost:11434/api/generate"
                            class="w-full p-3 rounded-lg focus:ring-2 transition mb-2"
                            style="border-color: var(--input-border);">
                        <label for="localModelName" class="block mb-2 font-semibold">اسم النموذج (مثال:
                            gemma:7b):</label>
                        <input type="text" id="localModelName" placeholder="gemma:7b"
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>

                    <div class="mb-6">
                      <label for="translatorSelect" class="block mb-2 font-semibold">اسم المترجم:</label>
                      <select id="translatorSelect" class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                        <option value="">اختر مترجماً</option>
                        <option value="Fatema Samy">Fatema Samy</option>
                        <option value="Samar Bahaaeldin">Samar Bahaaeldin</option>
                        <option value="Lobna Adel">Lobna Adel</option>
                        <option value="Shady Donia">Shady Donia</option>
                        <option value="Zeina Elsheikh">Zeina Elsheikh</option>
                        <option value="Aiat Saied">Aiat Saied</option>
                        <option value="Monica Sidhom">Monica Sidhom</option>
                        <option value="Yara Sobhy">Yara Sobhy</option>
                        <option value="Mariam Ghonaim">Mariam Ghonaim</option>
                        <option value="Hussein Mahmoud">Hussein Mahmoud</option>
                        <option value="Ahmed Sabra">Ahmed Sabra</option>
                        <option value="Ahmed Alhefny">Ahmed Alhefny</option>
                        <option value="Aya Abulmagd">Aya Abulmagd</option>
                        <option value="Gehan Khaled">Gehan Khaled</option>
                        <option value="Salma Hafez">Salma Hafez</option>
                        <option value="Hend El Husseiny">Hend El Husseiny</option>
                        <option value="Salma Zaki">Salma Zaki</option>
                        <option value="Esraa Shahien">Esraa Shahien</option>
                      </select>
                    </div>

                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="ephemeralKeysCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">عدم حفظ مفاتيح API محليًا (جلسة مؤقتة فقط)</span>
                        </label>
                    </div>
                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="useTmCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" checked
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">استخدام ذاكرة الترجمة (TM)</span>
                        </label>
                    </div>
                    <div class="mb-6">
                        <label class="inline-flex items-center gap-2">
                            <input id="useProofreadCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">تفعيل التدقيق اللغوي الآلي بعد الترجمة</span>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageSubjectsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">📚 إدارة المواد والصفوف</button>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageGlossaryBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">📖 إدارة القاموس المخصص</button>
                        <div class="flex items-center">
                            <input id="useGlossaryCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <label for="useGlossaryCheckbox" class="mr-2 text-sm font-medium">استخدام القاموس</label>
                        </div>
                    </div>

                    <div class="flex items-center justify-between p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageIdsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">🆔 إدارة معرفات الأسئلة (mapped_id)</button>
                    </div>
                </div>

                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">ملفات الأسئلة (JSON):</label>
                        <div id="fileUpload"
                            class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition"
                            style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">📤</div>
                            <p class="font-semibold">اسحب وأفلت الملفات هنا أو انقر للاختيار</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">يجب أن تكون الملفات بصيغة JSON
                            </p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>

            <button id="translateBtn"
                class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-8"
                style="background-color: var(--primary-color);">
                ترجمة الملفات (Ctrl + Enter)
            </button>
        </div>

        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
            <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto"
                style="border-color: var (--primary-color); border-top-color: transparent;"></div>
            <p id="progressText" class="mt-4 text-lg font-semibold">جاري الترجمة...</p>
            <div class="mt-3">
                <button id="cancelTranslationBtn"
                    class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">إلغاء</button>
            </div>
        </div>

        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">📊 تحليل الترجمة</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
        </div>

        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">الخطوة 2: معاينة وتعديل
                            الترجمة</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">راجع التراجم، عدّلها، وقارنها بالنص
                            الأصلي.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">↩️ تراجع</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">↪️ إعادة</button>
                        <button id="openAnnotatorBtn" class="px-3 py-2 rounded-lg"
                            title="تحرير النص فوق الصور (أرقام/رموز)">🖊️ محرر الصور</button>
                    </div>
                </div>
                <div class="preview-controls my-4 p-4 rounded-lg"
                    style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <div class="flex flex-wrap gap-4 items-center">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="البحث في النص الأصلي..."
                                class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-4"></div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg flex items-center justify-center gap-4">
                <label for="exportFormat" class="font-semibold">تنسيق التصدير:</label>
                <select id="exportFormat" class="p-2 rounded-lg">
                    <option value="json">JSON</option>
                    <option value="csv">CSV</option>
                </select>
                <button id="exportBtn"
                    class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105"
                    style="background-color: var(--success-color);">
                    تصدير الملفات المترجمة
                </button>
            </div>
        </div>
    </div>

    <!-- Modals (Glossary, Mapped IDs, Subjects) -->
    <!-- Image Annotator Modal -->
    <div id="imageAnnotatorModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-4 w-full max-w-4xl">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold" style="color: var(--primary-color);">تحرير نص فوق الصورة</h3>
                <button id="imageAnnotatorClose" class="text-2xl">&times;</button>
            </div>
            <div class="w-full overflow-auto" style="max-height:70vh">
                <canvas id="imageAnnotatorCanvas" class="w-full border"
                    style="border-color: var(--card-border);"></canvas>
            </div>
            <div class="flex justify-end gap-2 mt-3">
                <button id="imageAnnotatorSave" class="px-4 py-2 rounded-lg text-white"
                    style="background-color: var(--success-color);">حفظ</button>
            </div>
        </div>
    </div>
    <div id="glossaryModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog"
            aria-labelledby="glossaryTitle">
            <div class="flex justify-between items-center">
                <h3 id="glossaryTitle" class="text-2xl font-bold" style="color: var(--primary-color);">القاموس المخصص
                </h3>
                <button id="closeGlossaryModalBtn" class="text-2xl hover:opacity-75" aria-label="إغلاق">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">أضف المصطلحات وترجمتها المعتمدة لضمان
                الاتساق.</p>
            <div class="flex flex-wrap gap-2 mb-4">
                <button id="importGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg"
                    style="background-color: var(--primary-color);">استيراد</button>
                <button id="exportGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg"
                    style="background-color: var(--success-color);">تصدير (CSV)</button>
                <input type="file" id="glossaryFileInput" accept=".json,.csv" class="hidden">
            </div>
            <input type="text" id="glossarySearch" placeholder="البحث في القاموس..."
                class="w-full p-2 mb-4 border rounded-lg">

            <div class="grid md:grid-cols-3 gap-4 mb-4">
                <input type="text" id="glossaryTerm" placeholder="المصطلح الأصلي"
                    class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <input type="text" id="glossaryTranslation" placeholder="الترجمة المعتمدة"
                    class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <select id="glossaryCategory" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                    <option value="general">عام</option>
                    <option value="technical">تقني</option>
                    <option value="medical">طبي</option>
                    <option value="legal">قانوني</option>
                </select>
            </div>
            <button id="addGlossaryTermBtn" class="text-white px-4 py-2 rounded-lg w-full mb-4"
                style="background-color: var(--primary-color);">إضافة مصطلح</button>
            <hr class="my-4" style="border-color: var (--card-border);">
            <h4 class="text-lg font-semibold mb-2">المصطلحات المحفوظة</h4>
            <div id="glossaryListContainer" class="max-h-60 overflow-y-auto p-2 rounded-md"
                style="background-color: var(--bg-color);"></div>
        </div>
    </div>

    <div id="mappedIdsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog"
            aria-labelledby="mappedIdsTitle">
            <div class="flex justify-between items-center">
                <h3 id="mappedIdsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">إدارة معرفات
                    الأسئلة (mapped_id)</h3>
                <button id="closeMappedIdsModalBtn" class="text-2xl hover:opacity-75"
                    aria-label="إغلاق">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">أدخل عدد المعرفات المطلوبة ثم اضغط على
                الزر لجلبها تلقائياً، أو ألصقها يدوياً.</p>
            <div class="flex gap-2 mb-4">
                <input type="number" id="mappedIdsCount" placeholder="أدخل العدد"
                    class="p-2 border rounded-lg w-1/3 text-center">
                <button id="fetchMappedIdsBtn" class="flex-1 px-4 py-2 text-sm text-white rounded-lg"
                    style="background-color: var(--primary-color);">جلب الأكواد من Nagwa</button>
            </div>
            <textarea id="mappedIdsInput" rows="5" class="w-full p-2 rounded-lg mb-4"
                placeholder='["...","..."]'></textarea>
            <div class="flex items-center">
                <input id="useMappedIdsCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                    style="color: var(--primary-color);">
                <label for="useMappedIdsCheckbox" class="mr-2 text-sm font-medium">تفعيل استبدال المعرفات عند
                    التصدير</label>
            </div>
        </div>
    </div>

    <div id="subjectsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-3xl transform transition-all" role="dialog"
            aria-labelledby="subjectsTitle">
            <div class="flex justify-between items-center">
                <h3 id="subjectsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">إدارة المواد
                    والصفوف</h3>
                <button id="closeSubjectsModalBtn" class="text-2xl hover:opacity-75" aria-label="إغلاق">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">اختر المادة والصف لتطبيق تعليمات ترجمة
                مخصصة.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <select id="subjectSelect" class="p-2 border rounded-lg w-full"></select>
                <select id="gradeSelect" class="p-2 border rounded-lg w-full"></select>
            </div>
            <h4 class="text-lg font-semibold mb-2">معاينة التعليمات (البرومبت)</h4>
            <textarea id="promptPreview" rows="8" class="w-full p-2 rounded-lg mb-4" readonly></textarea>
            <button id="applyPromptBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg"
                style="background-color: var(--success-color);">تطبيق وحفظ</button>
        </div>
    </div>

    <script>

        const GOOGLE_SHEET_ID = '16-ant77j9ckFE7y48mOaqmMvUQrx8ZzM-ksWHaFNSUU';

        const TranslatorApp = {
            constants: {
                BATCH_SEPARATOR: "\\n|||---|||\\n",
                CONTEXT_SEPARATOR: "\\n<SEP>\\n",
                HISTORY_MAX: 20,
                CHUNK_SIZE: 40
            },

            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                glossary: [],
                activeScreen: 'setup',
                translationCache: new Map(),
                startTime: null,
                hasUnsavedChanges: false,
                selectedSubject: 'None',
                selectedGrade: 'None',
                fileStore: new Map(),
                isTranslating: false,
                translators: {
                  "Aya Abulmagd": "643164068106",
                  "Salma Hafez": "927169194769",
                  "Hend El Husseiny": "805189370751",
                  "Salma Zaki": "698106520137",
                  "Esraa Shahien": "937145789737",
                  "Fatema Samy": "719130548578",
                  "Samar Bahaaeldin": "694164363692",
                  "Lobna Adel": "925171517156",
                  "Shady Donia": "963163430437",
                  "Zeina Elsheikh": "154106968213",
                  "Aiat Saied": "942130798452",
                  "Monica Sidhom": "819178319024",
                  "Yara Sobhy": "618146184254",
                  "Mariam Ghonaim": "182136230818",
                  "Hussein Mahmoud": "676130390838",
                  "Gehan Khaled": "475149294140",
                  "Ahmed Sabra": "175196786128",
                  "Ahmed Alhefny": "120171982460"
                    },
                selectedTranslator: "",
            },

            dom: {},

            init() {
                try {
                    this.cacheDomElements();
                    this.bindEvents();
                    this.theme.init();
                    this.history.init();
                    this.subjects.init();
                    this.session.load();
                    this.shortcuts.init();
                    this.autoSave.init();
                    this.addBeforeUnloadGuard();
                    // Initialize shared MathLive virtual keyboard if available
                    try {
                        if (window.MathfieldElement && typeof MathfieldElement.makeSharedVirtualKeyboard === 'function') {
                            MathfieldElement.makeSharedVirtualKeyboard();
                        }
                    } catch (mathError) {
                        console.warn('MathLive initialization error:', mathError);
                    }
                } catch (error) {
                    console.error('Application initialization error:', error);
                    TranslatorApp.ui.showAlert('فشل في تهيئة التطبيق. يرجى إعادة تحميل الصفحة.', 'error');
                }
            },

            cacheDomElements() {
                try {
                    const ids = {
                        alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                        fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                        translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                        geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                        localModelGroup: 'localModelGroup', localModelUrl: 'localModelUrl', localModelName: 'localModelName',
                        setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                        previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                        manageGlossaryBtn: 'manageGlossaryBtn', glossaryModal: 'glossaryModal',
                        closeGlossaryModalBtn: 'closeGlossaryModalBtn', addGlossaryTermBtn: 'addGlossaryTermBtn',
                        glossaryTermInput: 'glossaryTerm', glossaryTranslationInput: 'glossaryTranslation',
                        glossaryListContainer: 'glossaryListContainer', useGlossaryCheckbox: 'useGlossaryCheckbox',
                        themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                        statsContainer: 'statsContainer', exportFormat: 'exportFormat',
                        searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                        importGlossaryBtn: 'importGlossaryBtn', exportGlossaryBtn: 'exportGlossaryBtn',
                        glossaryFileInput: 'glossaryFileInput', glossarySearch: 'glossarySearch',
                        glossaryCategory: 'glossaryCategory',
                        imageAnnotatorModal: 'imageAnnotatorModal',
                        imageAnnotatorCanvas: 'imageAnnotatorCanvas',
                        imageAnnotatorClose: 'imageAnnotatorClose',
                        imageAnnotatorSave: 'imageAnnotatorSave',
                        mappedIdsInput: 'mappedIdsInput', useMappedIdsCheckbox: 'useMappedIdsCheckbox',
                        manageIdsBtn: 'manageIdsBtn', mappedIdsModal: 'mappedIdsModal',
                        closeMappedIdsModalBtn: 'closeMappedIdsModalBtn',
                        mappedIdsCount: 'mappedIdsCount', fetchMappedIdsBtn: 'fetchMappedIdsBtn',
                        manageSubjectsBtn: 'manageSubjectsBtn', subjectsModal: 'subjectsModal',
                        closeSubjectsModalBtn: 'closeSubjectsModalBtn', subjectSelect: 'subjectSelect',
                        gradeSelect: 'gradeSelect', promptPreview: 'promptPreview', applyPromptBtn: 'applyPromptBtn',
                        cancelTranslationBtn: 'cancelTranslationBtn', saveIndicator: 'saveIndicator',
                        ephemeralKeysCheckbox: 'ephemeralKeysCheckbox',
                        useTmCheckbox: 'useTmCheckbox', useProofreadCheckbox: 'useProofreadCheckbox', translatorSelect: 'translatorSelect'
                    };
                    for (const k in ids) {
                        try {
                            this.dom[k] = document.getElementById(ids[k]);
                            if (!this.dom[k] && k !== 'glossaryCategory') {
                                console.warn(`DOM element not found: ${k}`);
                            }
                        } catch (elementError) {
                            console.warn(`Error caching DOM element ${k}:`, elementError);
                        }
                    }
                    this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
                } catch (error) {
                    console.error('Cache DOM elements error:', error);
                    throw new Error('فشل في تهيئة عناصر واجهة المستخدم');
                }
            },

            bindEvents() {
                try {
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            if (e.target.classList.contains('editable-unit')) {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handleUnitUpdate(fieldContainer, e.target.textContent);
                                }
                            } else {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        } catch (error) {
                            console.error('Preview input event error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        // ...existing code for Ctrl+M shortcut...

                        // Add this new section for handling Backspace/Delete
                        if (e.key === 'Backspace' || e.key === 'Delete') {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;

                            const range = selection.getRangeAt(0);
                            const focusNode = range.startContainer;
                            const parentMathField = focusNode.parentNode.closest('math-field');
                    
                            // Check if the parent is a math-field element and its content is empty
                            if (parentMathField && parentMathField.value.trim() === '') {
                                e.preventDefault();
                                const fieldContainer = parentMathField.closest('.editable-preview-field');
                                parentMathField.remove();
                                if (fieldContainer) {
                                    // Trigger an update after deletion
                                    TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        }
                    }, true);
                    
                    this.dom.newSessionBtn.addEventListener('click', (e) => {
                        try {
                            this.session.clear.bind(this.session)();
                        } catch (error) {
                            console.error('New session error:', error);
                            TranslatorApp.ui.showAlert('فشل في بدء جلسة جديدة.', 'error');
                        }
                    });
                    this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', (e) => {
                        try {
                            this.events.onApiProviderChange.bind(this)(e);
                        } catch (error) {
                            console.error('API provider radio change error:', error);
                        }
                    }));
                    this.dom.fileUpload.addEventListener('click', (e) => {
                        try {
                            this.dom.fileInput.click();
                        } catch (error) {
                            console.error('File upload click error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('dragover', (e) => {
                        try {
                            this.events.onDragOver(e);
                        } catch (error) {
                            console.error('Drag over error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        try {
                            const isEditable = e.target.closest('.editable-preview-field');
                            if (!isEditable) return;
                    
                            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') {
                                e.preventDefault();
                                const selection = window.getSelection();
                                if (!selection.rangeCount) return;
                                const range = selection.getRangeAt(0);
                                
                                // Create a new math-field element
                                const newMathField = document.createElement('math-field');
                                newMathField.setAttribute('default-mode', 'inline-math');
                                newMathField.setAttribute('value', '');
                                newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                newMathField.setAttribute('dir', 'ltr');
                                
                                // Insert the new math field
                                range.insertNode(newMathField);
                                
                                // Focus the cursor inside the new math field
                                newMathField.focus();
                    
                                TranslatorApp.preview.handlePreviewFieldUpdate(isEditable);
                            }
                        } catch (error) {
                            console.error('Math field shortcut error:', error);
                        }
                    }, true); // Use `true` for capture phase to ensure it runs before other handlers
                    
                    this.dom.fileUpload.addEventListener('dragleave', (e) => {
                        try {
                            this.events.onDragLeave(e);
                        } catch (error) {
                            console.error('Drag leave error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('drop', (e) => {
                        try {
                            this.events.onFileDrop.bind(this)(e);
                        } catch (error) {
                            console.error('File drop error:', error);
                        }
                    });
                    this.dom.fileInput.addEventListener('change', (e) => {
                        try {
                            this.events.onFileSelect.bind(this)(e);
                        } catch (error) {
                            console.error('File input change error:', error);
                        }
                    });
                    this.dom.translateBtn.addEventListener('click', (e) => {
                        try {
                            this.startTranslationProcess.bind(this)();
                        } catch (error) {
                            console.error('Start translation error:', error);
                            TranslatorApp.ui.showAlert('فشل في بدء عملية الترجمة.', 'error');
                        }
                    });
                    this.dom.cancelTranslationBtn.addEventListener('click', (e) => {
                        try {
                            this.api.cancel.bind(this.api)();
                        } catch (error) {
                            console.error('Cancel translation error:', error);
                        }
                    });
                    this.dom.exportBtn.addEventListener('click', (e) => {
                        try {
                            this.export.exportAs(this.dom.exportFormat.value);
                        } catch (error) {
                            console.error('Export error:', error);
                            TranslatorApp.ui.showAlert('فشل في تصدير الملفات.', 'error');
                        }
                    });
                    this.dom.geminiKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Gemini key input error:', error);
                        }
                    });
                    this.dom.chatgptKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('ChatGPT key input error:', error);
                        }
                    });
                    this.dom.localModelUrl.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model URL input error:', error);
                        }
                    });
                    this.dom.localModelName.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model name input error:', error);
                        }
                    });
                    this.dom.themeToggle.addEventListener('click', (e) => {
                        try {
                            this.theme.toggle.bind(this.theme)();
                        } catch (error) {
                            console.error('Theme toggle error:', error);
                        }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                    this.dom.ephemeralKeysCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Ephemeral keys checkbox error:', error);
                        }
                    });
                    this.dom.useTmCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use TM checkbox error:', error);
                        }
                    });
                    this.dom.useProofreadCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use proofread checkbox error:', error);
                        }
                    });

                    this.dom.searchPreview.addEventListener('input', (e) => {
                        try {
                            this.preview.filter.bind(this.preview)();
                        } catch (error) {
                            console.error('Search preview error:', error);
                        }
                    });
                    this.dom.undoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.undo.bind(this.history)();
                        } catch (error) {
                            console.error('Undo error:', error);
                            TranslatorApp.ui.showAlert('فشل في التراجع.', 'error');
                        }
                    });
                    this.dom.redoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.redo.bind(this.history)();
                        } catch (error) {
                            console.error('Redo error:', error);
                            TranslatorApp.ui.showAlert('فشل في الإعادة.', 'error');
                        }
                    });

                    this.dom.manageGlossaryBtn.addEventListener('click', () => {
                        try {
                            this.ui.showGlossaryModal(true);
                        } catch (error) {
                            console.error('Show glossary modal error:', error);
                        }
                    });
                    this.dom.closeGlossaryModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showGlossaryModal(false);
                        } catch (error) {
                            console.error('Close glossary modal error:', error);
                        }
                    });
                    this.dom.addGlossaryTermBtn.addEventListener('click', (e) => {
                        try {
                            this.glossary.add.bind(this.glossary)();
                        } catch (error) {
                            console.error('Add glossary term error:', error);
                            TranslatorApp.ui.showAlert('فشل في إضافة المصطلح.', 'error');
                        }
                    });
                    this.dom.exportGlossaryBtn.addEventListener('click', (e) => {
                        try {
                            this.glossary.export.bind(this.glossary)();
                        } catch (error) {
                            console.error('Export glossary error:', error);
                            TranslatorApp.ui.showAlert('فشل في تصدير القاموس.', 'error');
                        }
                    });
                    this.dom.importGlossaryBtn.addEventListener('click', () => {
                        try {
                            this.dom.glossaryFileInput.click();
                        } catch (error) {
                            console.error('Import glossary error:', error);
                        }
                    });
                    this.dom.glossaryFileInput.addEventListener('change', (e) => {
                        try {
                            this.glossary.import(e.target.files[0]);
                        } catch (error) {
                            console.error('Import glossary file error:', error);
                            TranslatorApp.ui.showAlert('فشل في استيراد القاموس.', 'error');
                        }
                    });
                    this.dom.glossarySearch.addEventListener('input', (e) => {
                        try {
                            this.glossary.filter(e.target.value);
                        } catch (error) {
                            console.error('Glossary search error:', error);
                        }
                    });

                    // Add event listener for glossary category if it exists
                    if (this.dom.glossaryCategory) {
                        this.dom.glossaryCategory.addEventListener('change', (e) => {
                            try {
                                this.state.hasUnsavedChanges = true;
                            } catch (error) {
                                console.error('Glossary category change error:', error);
                            }
                        });
                    }

                    this.dom.manageIdsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(true);
                        } catch (error) {
                            console.error('Show mapped IDs modal error:', error);
                        }
                    });
                    this.dom.closeMappedIdsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(false);
                        } catch (error) {
                            console.error('Close mapped IDs modal error:', error);
                        }
                    });
                    this.dom.fetchMappedIdsBtn.addEventListener('click', (e) => {
                        try {
                            this.mappedIds.fetch.bind(this.mappedIds)();
                        } catch (error) {
                            console.error('Fetch mapped IDs error:', error);
                            TranslatorApp.ui.showAlert('فشل في جلب المعرفات.', 'error');
                        }
                    });

                    this.dom.manageSubjectsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(true);
                        } catch (error) {
                            console.error('Show subjects modal error:', error);
                        }
                    });
                    this.dom.closeSubjectsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(false);
                        } catch (error) {
                            console.error('Close subjects modal error:', error);
                        }
                    });
                    this.dom.subjectSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onSubjectChange.bind(this.subjects)();
                        } catch (error) {
                            console.error('Subject change error:', error);
                        }
                    });
                    this.dom.gradeSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onGradeChange.bind(this.subjects)();
                        } catch (error) {
                            console.error('Grade change error:', error);
                        }
                    });
                    this.dom.applyPromptBtn.addEventListener('click', (e) => {
                        try {
                            this.subjects.apply.bind(this.subjects)();
                        } catch (error) {
                            console.error('Apply prompt error:', error);
                            TranslatorApp.ui.showAlert('فشل في تطبيق الإعدادات.', 'error');
                        }
                    });

                    // Image annotator events
                    const openAnnotatorBtn = document.getElementById('openAnnotatorBtn');
                    if (openAnnotatorBtn) {
                        openAnnotatorBtn.addEventListener('click', (e) => {
                            try {
                                this.annotator.open.bind(this.annotator)();
                            } catch (error) {
                                console.error('Open annotator error:', error);
                                TranslatorApp.ui.showAlert('فشل في فتح محرر الصور.', 'error');
                            }
                        });
                    }
                    this.dom.imageAnnotatorClose.addEventListener('click', (e) => {
                        try {
                            this.annotator.close.bind(this.annotator)();
                        } catch (error) {
                            console.error('Close annotator error:', error);
                        }
                    });
                    this.dom.imageAnnotatorSave.addEventListener('click', (e) => {
                        try {
                            this.annotator.save.bind(this.annotator)();
                        } catch (error) {
                            console.error('Save annotator error:', error);
                            TranslatorApp.ui.showAlert('فشل في حفظ الصورة.', 'error');
                        }
                    });

                    // Event delegation for all preview field updates
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            const fieldContainer = e.target.closest('.editable-preview-field');
                            if (fieldContainer) {
                                this.preview.handlePreviewFieldUpdate(fieldContainer);
                            }
                        } catch (error) {
                            console.error('Preview field update error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('copy', (e) => {
                        try {
                            this.preview.handleCopyEvent(e);
                        } catch (error) {
                            console.error('Copy event error:', error);
                        }
                    });

                    this.dom.previewContainer.addEventListener('paste', (e) => {
                        try {
                            this.preview.handlePasteEvent(e);
                        } catch (error) {
                            console.error('Paste event error:', error);
                        }
                    });
                    
                    // Ensure MathLive keyboard opens for inline chemistry/math on focus
                    this.dom.previewContainer.addEventListener('pointerdown', (e) => {
                        try {
                            const mf = e.target && e.target.closest && e.target.closest('math-field');
                            if (mf) {
                                try {
                                    mf.removeAttribute('read-only');
                                    mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    mf.setAttribute('use-shared-virtual-keyboard', '');
                                    if (typeof mf.executeCommand === 'function') {
                                        setTimeout(() => {
                                            try {
                                                mf.executeCommand('showVirtualKeyboard');
                                                mf.focus();
                                            } catch (err) {
                                                console.warn('MathLive keyboard error:', err);
                                            }
                                        }, 100);
                                    }
                                    e.stopPropagation();
                                } catch (err) {
                                    console.warn('MathLive setup error:', err);
                                }
                            }
                        } catch (error) {
                            console.error('MathLive pointerdown error:', error);
                        }
                    });
                    this.dom.translatorSelect.addEventListener('change', (e) => {
                      try {
                        const selectedName = e.target.value;
                        // Update the global state with the selected translator's name
                        TranslatorApp.state.selectedTranslator = selectedName;
                        TranslatorApp.state.hasUnsavedChanges = true;
                        if (selectedName) {
                          const sourceId = TranslatorApp.state.translators[selectedName];
                          TranslatorApp.ui.showAlert(`تم اختيار المترجم: ${selectedName} (ID: ${sourceId}).`, 'info', 3000);
                        } else {
                          TranslatorApp.ui.showAlert('لم يتم اختيار مترجم. لن تتم إضافة source_id.', 'warning', 3000);
                        }
                      } catch (error) {
                          console.error('Translator select change error:', error);
                          TranslatorApp.ui.showAlert('حدث خطأ أثناء اختيار المترجم.', 'error');
                      }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show the new mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show/hide the mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                } catch (error) {
                    console.error('bindEvents error:', error);
                    try { TranslatorApp.ui.showAlert('فشل في ربط الأحداث.', 'error'); } catch { }
                }
            },

            events: {
                onApiProviderChange(e) {
                    try {
                        const provider = e.target.value;
                        TranslatorApp.dom.geminiKeyGroup.classList.toggle('hidden', provider !== 'gemini');
                        TranslatorApp.dom.chatgptKeyGroup.classList.toggle('hidden', provider !== 'chatgpt');
                        TranslatorApp.dom.localModelGroup.classList.toggle('hidden', provider !== 'local');
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('API provider change error:', error);
                    }
                },
                onDragOver(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.add('dragover');
                    } catch (error) {
                        console.error('Drag over error:', error);
                    }
                },
                onDragLeave(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.remove('dragover');
                    } catch (error) {
                        console.error('Drag leave error:', error);
                    }
                },
                onFileDrop(e) {
                    try {
                        e.preventDefault();
                        TranslatorApp.dom.fileUpload.classList.remove('dragover');
                        TranslatorApp.fileHandler.addFiles(e.dataTransfer.files);
                    } catch (error) {
                        console.error('File drop error:', error);
                        TranslatorApp.ui.showAlert('فشل في إضافة الملفات.', 'error');
                    }
                },
                onFileSelect(e) {
                    try {
                        TranslatorApp.fileHandler.addFiles(e.target.files);
                    } catch (error) {
                        console.error('File select error:', error);
                        TranslatorApp.ui.showAlert('فشل في اختيار الملفات.', 'error');
                    }
                }
            },

            theme: {
                init() {
                    const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                    this.set(savedTheme);
                },
                toggle() {
                    const current = document.documentElement.getAttribute('data-theme');
                    this.set(current === 'dark' ? 'light' : 'dark');
                },
                set(themeName) {
                    document.documentElement.setAttribute('data-theme', themeName);
                    localStorage.setItem('translatorTheme', themeName);
                    TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? '☀️' : '🌙';
                }
            },

            shortcuts: {
                init() {
                    document.addEventListener('keydown', (e) => {
                        try {
                            if (e.ctrlKey || e.metaKey) {
                                const isEditable = e.target.closest('[contenteditable="true"]');
                                const isMathField = e.target.closest('math-field');
                                if (isEditable || isMathField) {
                                    return; // Exit and let the browser's native undo handle it.
                                }
                                switch (e.key.toLowerCase()) {
                                    case 's':
                                        e.preventDefault();
                                        TranslatorApp.session.save();
                                        TranslatorApp.ui.setSaveIndicator('saved');
                                        break;
                                    case 'o':
                                        e.preventDefault();
                                        TranslatorApp.dom.fileInput.click();
                                        break;
                                    case 'enter':
                                        if (TranslatorApp.state.activeScreen === 'setup') {
                                            e.preventDefault();
                                            TranslatorApp.dom.translateBtn.click();
                                        }
                                        break;
                                    case 'z':
                                        e.preventDefault();
                                        TranslatorApp.history.undo();
                                        break;
                                    case 'y':
                                        e.preventDefault();
                                        TranslatorApp.history.redo();
                                        break;
                                    case 'm':
                                        if (isEditable) {
                                            e.preventDefault();
                                            const selection = window.getSelection();
                                            if (!selection.rangeCount) return;
                                            const range = selection.getRangeAt(0);
                                    
                                            // Create and configure a new math-field element
                                            const newMathField = document.createElement('math-field');
                                            newMathField.setAttribute('default-mode', 'inline-math');
                                            newMathField.setAttribute('value', '');
                                            newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                            newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                            newMathField.setAttribute('dir', 'ltr');
                                            
                                            range.insertNode(newMathField);
                                            // Place cursor inside the new math field
                                            newMathField.focus();
                                    
                                            TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                        }
                                        break;
                                }
                            }

                            // MathLive language toggle shortcut (Alt + L)
                            if (e.ctrlKey && e.altKey && e.key === 'k') {
                                e.preventDefault();
                                TranslatorApp.utils.mathLive.toggleLanguage();
                            }

                        } catch (error) {
                            console.error('Shortcut error:', error);
                        }
                    });
                }
            },

            addBeforeUnloadGuard() {
                window.addEventListener('beforeunload', (e) => {
                    try {
                        if (TranslatorApp.state.hasUnsavedChanges) {
                            e.preventDefault();
                            e.returnValue = '';
                        }
                    } catch (error) {
                        console.error('Before unload error:', error);
                    }
                });
            },

            utils: {
                collectAllTextsFromFiles(filesArr) {
                    const bag = new Set();
                    const toPlain = (html) => {
                        if (typeof html !== 'string') return '';
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        return (div.textContent || div.innerText || '').trim();
                    };

                    const traverse = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => traverse(item));
                        } else if (typeof obj === 'object') {
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                // **IMPROVEMENT**: More specific keys to check for translatable content
                                const translatableKeys = ['stem', 'html_content', 'answer', 'statement'];
                                if (translatableKeys.includes(key) && typeof value === 'string') {
                                    const plain = toPlain(value);
                                    if (plain) bag.add(plain);
                                } else if (key === 'gap_text_keys' && Array.isArray(value)) {
                                    value.forEach(item => {
                                        if (item && typeof item.value === 'string') {
                                            const plain = toPlain(item.value);
                                            if (plain) bag.add(plain);
                                        }
                                    });
                                }
                                else {
                                    traverse(value);
                                }
                            });
                        }
                    };

                    filesArr.forEach(f => {
                        if (f.data) traverse(f.data);
                    });

                    return Array.from(bag);
                },
                escapeRegex(str) { return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); },

                // MathLive language utilities
                mathLive: {
                    // Toggle language for all math fields
                    toggleLanguage() {
                        try {
                            const mathFields = document.querySelectorAll('math-field');
                            mathFields.forEach(mf => {
                                const currentLang = mf.getAttribute('virtual-keyboard-default-language') || 'ar';
                                const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                mf.setAttribute('virtual-keyboard-default-language', newLang);
                                mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');
                            });

                            const langText = newLang === 'ar' ? 'العربية' : 'English';
                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText} لجميع الحقول الرياضية`, 'info', 2000);
                        } catch (error) {
                            console.error('Toggle language error:', error);
                        }
                    },

                    // Set language for specific math field
                    setLanguage(mathField, language) {
                        try {
                            if (!mathField || !language) return;

                            mathField.setAttribute('virtual-keyboard-default-language', language);
                            mathField.setAttribute('dir', language === 'ar' ? 'rtl' : 'ltr');

                            const langText = language === 'ar' ? 'العربية' : 'English';
                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText}`, 'info', 1500);
                        } catch (error) {
                            console.error('Set language error:', error);
                        }
                    },

                    // Get current language of math field
                    getLanguage(mathField) {
                        try {
                            if (!mathField) return 'ar';
                            return mathField.getAttribute('virtual-keyboard-default-language') || 'ar';
                        } catch (error) {
                            console.error('Get language error:', error);
                            return 'ar';
                        }
                    },

                    // Detect language from text content
                    detectLanguage(text) {
                        try {
                            if (!text || typeof text !== 'string') return 'ar';

                            const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
                            const hasEnglish = /[a-zA-Z]/.test(text);

                            if (hasArabic && !hasEnglish) return 'ar';
                            if (hasEnglish && !hasArabic) return 'en';
                            return 'ar'; // Default to Arabic
                        } catch (error) {
                            console.error('Detect language error:', error);
                            return 'ar';
                        }
                    }
                },

                // Advanced text direction detection and processing
                textDirection: {
                    // Detect if text is primarily Arabic
                    isArabic(text) {
                        if (!text || typeof text !== 'string') return false;
                        const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                        return arabicRegex.test(text);
                    },

                    // Detect if text is primarily English/Latin
                    isLatin(text) {
                        if (!text || typeof text !== 'string') return false;
                        const latinRegex = /[a-zA-Z]/;
                        return latinRegex.test(text);
                    },

                    // Detect if text contains numbers
                    hasNumbers(text) {
                        if (!text || typeof text !== 'string') return false;
                        return /[\d٠-٩]/.test(text);
                    },

                    // Detect if text is mixed (Arabic + Latin)
                    isMixed(text) {
                        if (!text || typeof text !== 'string') return false;
                        return this.isArabic(text) && this.isLatin(text);
                    },

                    // Get dominant text direction
                    getDominantDirection(text) {
                        if (!text || typeof text !== 'string') return 'rtl';

                        const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                        const latinChars = (text.match(/[a-zA-Z]/g) || []).length;

                        if (arabicChars > latinChars) return 'rtl';
                        if (latinChars > arabicChars) return 'ltr';
                        return 'rtl'; // Default to RTL for Arabic interface
                    },

                    // Process mixed content and add appropriate markup
                    processMixedContent(text) {
                        if (!text || typeof text !== 'string') return text;

                        try {
                            let processed = text;

                            // Handle Arabic numerals (٠-٩)
                            

                            // Handle English numerals in Arabic context
                            

                            // Handle English words/phrases in Arabic text
                            if (this.isArabic(text) && this.isLatin(text)) {
                                processed = processed.replace(/([a-zA-Z][a-zA-Z0-9\s\-_]*[a-zA-Z0-9]|[a-zA-Z])/g, (match) => {
                                    // Don't wrap if it's already wrapped
                                    if (match.includes('<span')) return match;
                                    return `<span class="english-phrase" dir="ltr">${match}</span>`;
                                });
                            }

                            return processed;
                        } catch (error) {
                            console.error('Process mixed content error:', error);
                            return text;
                        }
                    },

                    // Apply smart direction classes to element
                    applySmartDirection(element, text) {
                        if (!element || !text) return;

                        try {
                            const direction = this.getDominantDirection(text);
                            const isMixed = this.isMixed(text);

                            // Remove existing direction classes
                            element.classList.remove('rtl-auto', 'ltr-auto', 'text-mixed', 'mixed-content');

                            if (isMixed) {
                                element.classList.add('mixed-content');
                                element.setAttribute('dir', 'auto');
                            } else if (direction === 'rtl') {
                                element.classList.add('rtl-auto');
                                element.setAttribute('dir', 'rtl');
                            } else {
                                element.classList.add('ltr-auto');
                                element.setAttribute('dir', 'ltr');
                            }

                            // Add unicode-bidi for better rendering
                            if (isMixed) {
                                element.style.unicodeBidi = 'plaintext';
                            } else {
                                element.style.unicodeBidi = 'embed';
                            }
                        } catch (error) {
                            console.error('Apply smart direction error:', error);
                        }
                    },

                    // Enhanced content processing for preview
                    enhancePreviewContent(htmlString) {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;

                        try {
                            // Create a temporary container to work with DOM
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = htmlString;

                            // Process all text nodes
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            textNodes.forEach(textNode => {
                                const text = textNode.textContent;
                                if (text && text.trim()) {
                                    const processedText = this.processMixedContent(text);
                                    if (processedText !== text) {
                                        const wrapper = document.createElement('span');
                                        wrapper.innerHTML = processedText;
                                        this.applySmartDirection(wrapper, text);
                                        textNode.parentNode.replaceChild(wrapper, textNode);
                                    }
                                }
                            });

                            // Apply direction to container elements
                            const elements = tempDiv.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
                            elements.forEach(el => {
                                const text = el.textContent;
                                if (text && text.trim()) {
                                    this.applySmartDirection(el, text);
                                }
                            });

                            return tempDiv.innerHTML;
                        } catch (error) {
                            console.error('Enhance preview content error:', error);
                            return htmlString;
                        }
                    }
                },
                /**
                 * دالة لتحليل نص HTML، استخراج النصوص القابلة للترجمة، وتوليد هيكل HTML مع نصوص نائبة.
                 * @param {string} htmlString - كود HTML المراد تحليله.
                 * @param {object} basePointer - معلومات لتحديد مصدر النص (رقم الملف، الجزء، إلخ).
                 * @returns {{jobs: Array, parsedBody: HTMLElement}} - كائن يحتوي على قائمة مهام الترجمة والهيكل.
                 */
                parseHtmlAndCreateJobs(htmlString, basePointer) {
                    const jobs = [];
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(`<!DOCTYPE html><body>${htmlString}</body>`, 'text/html');
                    const body = doc.body;

                    function traverse(node) {
                        if (!node) return;
                        if (node.nodeType === 3) { // Text node
                            const text = (node.nodeValue || '').trim();
                            if (text) {
                                jobs.push({
                                    type: 'text_node',
                                    originalText: text,
                                    pointer: { ...(basePointer || {}) },
                                    domNode: node
                                });
                            }
                            return;
                        }
                        if (node.nodeType === 1) { // Element
                            const tag = (node.tagName || '').toUpperCase();
                            if (tag === 'SCRIPT' || tag === 'STYLE') return;
                            for (const child of Array.from(node.childNodes || [])) traverse(child);
                        }
                    }

                    traverse(body);
                    return { jobs, parsedBody: body };
                }
            },

            remoteGlossary: {
                map: {},
                async fetchApproved(subject, texts) {
                    this.map = {};
                    if (!subject || subject === 'None') return this.map;
                    try {
                        const tq = `select A,B where C = '${(subject || '').replace(/'/g, "\\'")}'`;
                        const url = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?sheet=termbase&tqx=out:json&headers=1&tq=${encodeURIComponent(tq)}`;
                        const res = await fetch(url, { cache: 'no-cache' });
                        const raw = await res.text();
                        const match = raw.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/);
                        if (!match) throw new Error('تعذّر قراءة استجابة gviz.');
                        const data = JSON.parse(match[1]);
                        const rows = data.table?.rows || [];
                        const allPairs = rows.map(r => ({
                            term: (r.c?.[0]?.v || '').toString().trim(),
                            translation: (r.c?.[1]?.v || '').toString().trim()
                        })).filter(x => x.term && x.translation);

                        const loweredTexts = Array.isArray(texts) ? texts.map(t => (t || '').toString().toLowerCase()) : [];
                        const map = {};
                        if (loweredTexts.length > 0) {
                            allPairs.forEach(({ term, translation }) => {
                                const tl = term.toLowerCase();
                                if (loweredTexts.some(tx => tx.includes(tl))) map[term] = translation;
                            });
                        } else {
                            allPairs.forEach(({ term, translation }) => { map[term] = translation; });
                        }
                        this.map = map;
                        return this.map;
                    } catch (e) {
                        console.warn('GVIZ fetch failed:', e);
                        TranslatorApp.ui.showAlert('تعذّر جلب المصطلحات المعتمدة (سيتم الاستمرار بدونها).', 'info', 4000);
                        this.map = {};
                        return this.map;
                    }
                },
                applyWithPlaceholders(text) {
                    if (!text || !this.map || Object.keys(this.map).length === 0) {
                        return { modifiedText: text, placeholders: {} };
                    }
                    let modifiedText = text;
                    const placeholders = {};
                    let i = 0;
                    const terms = Object.keys(this.map).filter(Boolean).sort((a, b) => b.length - a.length);
                    for (const term of terms) {
                        const translation = this.map[term];
                        if (!translation) continue;
                        const esc = TranslatorApp.utils.escapeRegex(term.trim());
                        const useWordBoundary = /^[A-Za-z0-9 _-]+$/.test(term);
                        const re = new RegExp(useWordBoundary ? `\\b${esc}\\b` : esc, 'gi');
                        if (re.test(modifiedText)) {
                            const ph = `__GLOSSARY_${i++}__`;
                            placeholders[ph] = translation;
                            modifiedText = modifiedText.replace(re, ph);
                        }
                    }
                    return { modifiedText, placeholders };
                },
                revertPlaceholders(text, placeholders) {
                    if (!placeholders || !text) return text;
                    let out = text;
                    for (const [ph, tr] of Object.entries(placeholders)) out = out.split(ph).join(tr);
                    return out;
                }
            },

            security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) {
                    try {
                        if (!key || typeof key !== 'string') return '';
                        return btoa(key + this.SALT);
                    } catch (error) {
                        console.warn('Encryption error:', error);
                        return '';
                    }
                },
                decrypt(encryptedKey) {
                    try {
                        if (!encryptedKey || typeof encryptedKey !== 'string') return '';
                        const decoded = atob(encryptedKey);
                        return decoded.endsWith(this.SALT) ? decoded.slice(0, -this.SALT.length) : '';
                    } catch (error) {
                        console.warn('Decryption error:', error);
                        return '';
                    }
                },
                sanitize(html) {
                    if (typeof html !== 'string') return html;
                    try {
                        if (window.DOMPurify) {
                            return DOMPurify.sanitize(html, {
                                ALLOWED_TAGS: ['b', 'i', 'u', 'em', 'strong', 'sub', 'sup', 'br', 'span', 'p', 'ul', 'ol', 'li', 'img', 'a', 'code', 'pre', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'math', 'div', 'math-field', 'audio'],
                                ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'style', 'dir', 'value', 'default-mode', 'data-path', 'data-file-index', 'data-blank', 'read-only', 'controls', 'virtual-keyboard-mode', 'use-shared-virtual-keyboard', 'data-node-type', 'data-node-variation']
                            });
                        }
                        // Fallback sanitization
                        return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                    } catch (error) {
                        console.warn('HTML sanitization error:', error);
                        // Return a safe fallback
                        return html ? html.replace(/<[^>]*>/g, '') : '';
                    }
                }
            },

            quality: {
                unitsMap: {
                    'pounds': 'جنيه',
                    'pound': 'جنيه',
                    'cm': 'سم',
                    'mm': 'مم',
                    'km': 'كم',
                    'm': 'م',
                    'kg': 'كجم',
                    'g': 'جم',
                    'l': 'ل',
                    'L': 'ل',
                    'ml': 'مل',
                    's': 'ث',
                    'min': 'د',
                    'h': 'س'
                },
                wantsArabicIndicDigits(subject, grade) {
                    if (subject === 'Mathematics' && ['Grades 1–3', 'Grades 8–12'].includes(grade)) return true;
                    if (subject === 'Science' && grade === 'Grade 9') return true;
                    return false;
                },
                cleanLatexArabic(text) {
                    if (typeof text !== 'string') return text;
                    // This is a simple but effective fix for the specific issue
                    return text.replace(/\\alt{\\alef}\\prime/g, '')
                               .replace(/\\lam/g, 'والباقي ');
                },
                
                protectSegments(text) {
                    const placeholders = {};
                    let idx = 0;
                    const patterns = [
                        /<math-field[\s\S]*?<\/math-field>/g,
                        /<audio[\s\S]*?<\/audio>/g,
                        /<img[^>]*>/g,
                        // Don't protect tables - let their content be translated
                        // /<table[\s\S]*?<\/table>/g,
                        /_{3,}/g,
                        /```[\s\S]*?```/g,
                        /`[^`]*`/g,
                        /\$\$[\s\S]*?\$\$/g,
                        /\$[^$]*\$/g,
                        /\\\[[\s\S]*?\\]/g,
                        /\\\([\s\S]*?\\\)/g,
                        /https?:\/\/\S+/g,
                        // Protect Lexical theme elements that might interfere with translation
                        /<span[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/span>/g,
                        /<p[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/p>/g
                    ];
                    let protectedText = String(text || '');
                    for (const re of patterns) {
                        protectedText = protectedText.replace(re, (m) => { const ph = `__LOCK_${idx++}__`; placeholders[ph] = m; return ph; });
                    }
                    return { protectedText, placeholders };
                },
                restoreSegments(text, placeholders) {
                    if (!placeholders) return text;
                    let out = text || '';
                    for (const [ph, val] of Object.entries(placeholders)) out = out.split(ph).join(val);
                    return out;
                },
                convertDigits(str, toArabicIndic) {
                    const en = '0123456789'.split(''); const ar = '٠١٢٣٤٥٦٧٨٩'.split('');
                    if (toArabicIndic) return (str || '').replace(/[0-9]/g, ch => ar[+ch]);
                    return (str || '').replace(/[٠-٩]/g, ch => en[ar.indexOf(ch)]);
                },
                normalizeArabicPunct(str) {
                    return (str || '')
                        .replace(/ ,/g, '،')
                        .replace(/, /g, '، ')
                        .replace(/,/g, '،')
                        .replace(/;/g, '؛')
                        .replace(/\?/g, '؟')
                        .replace(/["""]/g, '»')
                        .replace(/'/g, 'ʼ')
                        .replace(/\s+([،؛؟])/g, '$1')
                        .replace(/([،؛])(?=[^\s])/g, '$1 ')
                        .replace(/\s+/g, ' ');
                },
                enforceUnits(str) {
                    const map = { cm: 'سم', mm: 'مم', km: 'كم', m: 'م', kg: 'كجم', g: 'جم', l: 'ل', L: 'ل', ml: 'مل', s: 'ث', min: 'د', h: 'س' };
                    return (str || '').replace(/(\d[0-9٠-٩.,]*)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                },
                postProcess(text, ctx = { subject: 'None', grade: 'None' }) {
                    let out = text || '';
                    // Add a new rule to replace the remainder symbol
                    out = out.replace(/R\s*(\d+)/g, ' والباقي $1');
                    const toArabic = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
                    out = this.convertDigits(out, toArabic);
                    out = this.enforceUnits(out);
                    out = this.normalizeArabicPunct(out);
                    out = out.replace(/»([^»«]+)»/g, '«$1»');
                    return out;
                },
                qa: {
                    extractPlain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim(); },
                    unifyDigits(s) { const ar = '٠١٢٣٤٥٦٧٨٩'; return (s || '').replace(/[٠-٩]/g, d => String(ar.indexOf(d))); },
                    extractNumbers(s) { return Array.from((s || '').matchAll(/[0-9٠-٩]+(?:[.,][0-9٠-٩]+)?/g)).map(m => m[0]); },
                    sameNumberSet(srcArr, dstArr) {
                        const a = srcArr.map(this.unifyDigits).sort().join('|');
                        const b = dstArr.map(this.unifyDigits).sort().join('|');
                        return a === b;
                    },
                    checkNumbers(srcHtml, dstHtml) {
                        const s = this.extractPlain(srcHtml); const d = this.extractPlain(dstHtml);
                        const srcNums = this.extractNumbers(s); const dstNums = this.extractNumbers(d);
                        return this.sameNumberSet(srcNums, dstNums) ? [] : [`تحذير: تغيرت/اختفت أرقام (${srcNums.join(',')}) → (${dstNums.join(',')}).`];
                    },
                    checkSeparator(dstText, sep) {
                        if (!dstText) return [];
                        const want = (dstText.match(new RegExp(sep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g')) || []).length;
                        const legacy = (dstText.match(/<SEP>/g) || []).length;
                        if (legacy > 0 && want === 0) return ['تحذير: لم يُحفظ الفاصل <SEP> كما هو.'];
                        return [];
                    },
                    checkHtmlBalance(dstHtml) {
                        const tags = ['b', 'i', 'u', 'strong', 'em', 'sub', 'sup', 'span', 'p', 'ul', 'ol', 'li'];
                        const errs = [];
                        tags.forEach(t => {
                            const open = (dstHtml.match(new RegExp(`<${t}\\b`, 'gi')) || []).length;
                            const close = (dstHtml.match(new RegExp(`</${t}>`, 'gi')) || []).length;
                            if (open !== close) errs.push(`تحذير: الوسم <${t}> غير متوازن (${open}/${close}).`);
                        });
                        return errs;
                    }
                }
            },

            tm: {
                KEY: 'translatorTMv1',
                getStore() { try { return JSON.parse(localStorage.getItem(this.KEY) || '{}'); } catch { return {}; } },
                saveStore(obj) { localStorage.setItem(this.KEY, JSON.stringify(obj)); },
                plain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim().toLowerCase(); },
                key(text, ctx) { return `${ctx.subject}||${ctx.grade}||${this.plain(text)}`; },
                get(text, ctx) { const store = this.getStore(); return store[this.key(text, ctx)] || null; },
                put(text, ctx, translated) {
                    const store = this.getStore();
                    const k = this.key(text, ctx);
                    store[k] = translated;
                    this.saveStore(store);
                }
            },

            session: {
                save() {
                    try {
                        const ephemeral = TranslatorApp.dom.ephemeralKeysCheckbox.checked;
                        const sessionData = {
                            apiKeys: ephemeral ? null : {
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                            },
                            localModelUrl: TranslatorApp.dom.localModelUrl.value,
                            localModelName: TranslatorApp.dom.localModelName.value,
                            selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                            selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                            originalJsonData: TranslatorApp.state.originalJsonData,
                            translatedJsonData: TranslatorApp.state.translatedJsonData,
                            glossary: TranslatorApp.state.glossary,
                            activeScreen: TranslatorApp.state.activeScreen,
                            mappedIds: TranslatorApp.dom.mappedIdsInput.value,
                            useMappedIds: TranslatorApp.dom.useMappedIdsCheckbox.checked,
                            selectedSubject: TranslatorApp.state.selectedSubject,
                            selectedGrade: TranslatorApp.state.selectedGrade,
                            ephemeralKeys: ephemeral,
                            useTM: TranslatorApp.dom.useTmCheckbox.checked,
                            useProofread: TranslatorApp.dom.useProofreadCheckbox.checked
                        };
                        localStorage.setItem('translatorSession', JSON.stringify(sessionData));

                        // Always save API keys to sessionStorage for persistence across browser sessions
                        if (TranslatorApp.dom.geminiKeyInput.value || TranslatorApp.dom.chatgptKeyInput.value) {
                            sessionStorage.setItem('translatorPersistentKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                                provider: document.querySelector('input[name="apiProvider"]:checked').value
                            }));
                        }

                        if (ephemeral) {
                            sessionStorage.setItem('translatorEphemeralKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value)
                            }));
                        } else {
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        }

                        TranslatorApp.state.hasUnsavedChanges = false;
                    } catch (error) {
                        console.error('Session save error:', error);
                        TranslatorApp.ui.showAlert('فشل في حفظ الجلسة.', 'error');
                    }
                },
                load() {
                    const saved = localStorage.getItem('translatorSession');
                    if (!saved) return;
                    try {
                        const s = JSON.parse(saved);
                        TranslatorApp.dom.ephemeralKeysCheckbox.checked = !!s.ephemeralKeys;

                        // Load API keys with fallback to persistent storage
                        let keysLoaded = false;
                        if (s.apiKeys && !s.ephemeralKeys) {
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.chatgpt || '');
                            keysLoaded = true;
                        } else if (s.ephemeralKeys) {
                            const sk = JSON.parse(sessionStorage.getItem('translatorEphemeralKeys') || '{}');
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sk?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sk?.chatgpt || '');
                            keysLoaded = true;
                        }

                        // Fallback to persistent keys if no keys loaded from session
                        if (!keysLoaded) {
                            const persistentKeys = JSON.parse(sessionStorage.getItem('translatorPersistentKeys') || '{}');
                            if (persistentKeys.gemini || persistentKeys.chatgpt) {
                                TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.gemini || '');
                                TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.chatgpt || '');
                                if (persistentKeys.provider) {
                                    const radio = document.querySelector(`input[name="apiProvider"][value="${persistentKeys.provider}"]`);
                                    if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: persistentKeys.provider } }); }
                                }
                            }
                        }

                        TranslatorApp.dom.localModelUrl.value = s.localModelUrl || 'http://localhost:11434/api/generate';
                        TranslatorApp.dom.localModelName.value = s.localModelName || 'gemma:7b';
                        TranslatorApp.state.selectedFilesInfo = s.selectedFilesInfo || [];
                        TranslatorApp.state.originalJsonData = s.originalJsonData || [];
                        TranslatorApp.state.translatedJsonData = s.translatedJsonData || [];
                        TranslatorApp.state.glossary = s.glossary || [];
                        TranslatorApp.state.activeScreen = s.activeScreen || 'setup';
                        TranslatorApp.dom.mappedIdsInput.value = s.mappedIds || '[]';
                        TranslatorApp.dom.useMappedIdsCheckbox.checked = s.useMappedIds || false;
                        TranslatorApp.state.selectedSubject = s.selectedSubject || 'None';
                        TranslatorApp.state.selectedGrade = s.selectedGrade || 'None';
                        TranslatorApp.dom.useTmCheckbox.checked = s.useTM ?? true;
                        TranslatorApp.dom.useProofreadCheckbox.checked = s.useProofread ?? false;

                        if (s.selectedProvider && !keysLoaded) {
                            const radio = document.querySelector(`input[name="apiProvider"][value="${s.selectedProvider}"]`);
                            if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: s.selectedProvider } }); }
                        }

                        TranslatorApp.ui.renderFileList();
                        TranslatorApp.glossary.render();
                        TranslatorApp.subjects.updateUI();

                        if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                            TranslatorApp.ui.showScreen('preview');
                            TranslatorApp.preview.render();
                            const stats = TranslatorApp.statistics.calculate();
                            TranslatorApp.ui.renderStatistics(stats);
                            TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        } else {
                            TranslatorApp.ui.showScreen('setup');
                        }

                        TranslatorApp.ui.showAlert('تم استعادة الجلسة السابقة بنجاح.', 'success');
                    } catch (e) {
                        console.error('خطأ في استعادة الجلسة:', e);
                        TranslatorApp.ui.showAlert('حدث خطأ أثناء استعادة الجلسة السابقة. سيتم بدء جلسة جديدة.', 'error');

                        // Clear corrupted session data
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        } catch (clearError) {
                            console.error('Error clearing corrupted session:', clearError);
                        }
                    }
                },
                clear() {
                    const btn = TranslatorApp.dom.newSessionBtn;
                    if (btn.dataset.confirm === 'true') {
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                            // Keep persistent API keys unless user explicitly wants to clear everything
                            // sessionStorage.removeItem('translatorPersistentKeys');
                            location.reload();
                        } catch (error) {
                            console.error('Session clear error:', error);
                            TranslatorApp.ui.showAlert('فشل في مسح الجلسة. يرجى إعادة تحميل الصفحة يدوياً.', 'error');
                        }
                    } else {
                        btn.dataset.confirm = 'true';
                        btn.textContent = 'هل أنت متأكد؟ انقر مجدداً';
                        btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                        setTimeout(() => {
                            btn.dataset.confirm = 'false';
                            btn.textContent = 'بدء جلسة جديدة';
                            btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                            btn.classList.add('bg-red-500', 'hover:bg-red-600');
                        }, 3000);
                    }
                }
            },

            autoSave: {
                init() {
                    setInterval(() => {
                        try {
                            if (TranslatorApp.state.hasUnsavedChanges) {
                                TranslatorApp.session.save();
                                TranslatorApp.ui.setSaveIndicator('saving');
                                setTimeout(() => TranslatorApp.ui.setSaveIndicator('saved'), 400);
                            }
                        } catch (error) {
                            console.error('Auto-save error:', error);
                            TranslatorApp.ui.setSaveIndicator('error');
                            setTimeout(() => TranslatorApp.ui.setSaveIndicator(''), 2000);
                        }
                    }, 8000);
                }
            },

            validation: {
                validateJsonStructure(data, fileName) {
                    if (typeof data !== 'object' || data === null) {
                        throw new Error(`ملف ${fileName} يجب أن يكون كائن JSON صالح.`);
                    }
                    if (!data.hasOwnProperty('parts')) {
                        throw new Error(`ملف ${fileName} يفتقد للحقل المطلوب (parts).`);
                    }
                    if (!Array.isArray(data.parts)) {
                        throw new Error(`حقل parts في ملف ${fileName} يجب أن يكون مصفوفة.`);
                    }
                    return true;
                },
                validateApiKey(key, provider) {
                    if (!key || typeof key !== 'string') return false;
                    const trimmedKey = key.trim();
                    if (trimmedKey.length === 0) return false;

                    if (provider === 'gemini') {
                        return trimmedKey.startsWith('AIza') && trimmedKey.length > 30;
                    }
                    if (provider === 'chatgpt') {
                        return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                    }
                    if (provider === 'local') {
                        // For local models, we validate URL and model name separately
                        return true;
                    }
                    return false;
                },
                validateLocalModelSettings(url, modelName) {
                    if (!url || typeof url !== 'string' || url.trim().length === 0) {
                        return { valid: false, message: 'عنوان URL للخادم المحلي مطلوب.' };
                    }
                    if (!modelName || typeof modelName !== 'string' || modelName.trim().length === 0) {
                        return { valid: false, message: 'اسم النموذج المحلي مطلوب.' };
                    }
                    return { valid: true };
                }
            },

            fileHandler: {
                addFiles(files) {
                    const incoming = Array.from(files).filter(f => {
                        if (!f) return false;
                        const isJson = f.type === 'application/json' || f.name.toLowerCase().endsWith('.json');
                        if (!isJson) {
                            TranslatorApp.ui.showAlert(`الملف ${f.name} ليس ملف JSON صالح.`, 'error');
                            return false;
                        }
                        return true;
                    });

                    if (incoming.length === 0) {
                        TranslatorApp.ui.showAlert('لم يتم العثور على ملفات JSON صالحة.', 'error');
                        return;
                    }

                    incoming.forEach(file => {
                        TranslatorApp.state.fileStore.set(file.name, file);
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        } else {
                            const idx = TranslatorApp.state.selectedFilesInfo.findIndex(f => f.name === file.name);
                            if (idx > -1) TranslatorApp.state.selectedFilesInfo[idx].size = file.size;
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showAlert(`تم إضافة ${incoming.length} ملف بنجاح.`, 'success');
                },
                removeFile(index) {
                    const info = TranslatorApp.state.selectedFilesInfo[index]; if (!info) return;
                    const name = info.name;
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    if (TranslatorApp.state.fileStore.has(name)) TranslatorApp.state.fileStore.delete(name);
                    const origIdx = TranslatorApp.state.originalJsonData.findIndex(d => d.name === name);
                    if (origIdx > -1) TranslatorApp.state.originalJsonData.splice(origIdx, 1);
                    const transIdx = TranslatorApp.state.translatedJsonData.findIndex(d => d.name === name);
                    if (transIdx > -1) TranslatorApp.state.translatedJsonData.splice(transIdx, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                async readFilesFromInput() {
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) throw new Error("لا توجد ملفات محددة.");
                    TranslatorApp.state.originalJsonData = [];
                    const inputFiles = Array.from(TranslatorApp.dom.fileInput.files || []);

                    for (const { name } of TranslatorApp.state.selectedFilesInfo) {
                        try {
                            const file = TranslatorApp.state.fileStore.get(name) || inputFiles.find(f => f.name === name);
                            if (!file) throw new Error(`لم يتم العثور على الملف ${name}. يرجى إعادة تحديده.`);

                            const content = await file.text();
                            if (!content || content.trim() === '') {
                                throw new Error(`الملف ${name} فارغ.`);
                            }

                            let jsonData;
                            try {
                                jsonData = JSON.parse(content);
                            } catch (parseError) {
                                throw new Error(`الملف ${name} يحتوي على JSON غير صالح: ${parseError.message}`);
                            }

                            TranslatorApp.validation.validateJsonStructure(jsonData, name);
                            TranslatorApp.state.originalJsonData.push({ name, data: jsonData });

                        } catch (fileError) {
                            console.error(`Error reading file ${name}:`, fileError);
                            throw new Error(`خطأ في قراءة الملف ${name}: ${fileError.message}`);
                        }
                    }
                }
            },

            mappedIds: {
                async fetch() {
                    const count = TranslatorApp.dom.mappedIdsCount.value;
                    if (!count || count <= 0) return TranslatorApp.ui.showAlert('الرجاء إدخال عدد صحيح.', 'error');
                    const url = `https://12digit.nagwa.com/get.bulk.codes/${count}/cps/cps.system/`;
                    TranslatorApp.ui.showAlert(`جاري جلب ${count} كود...`, 'info', 3000);
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });
                        if (!response.ok) throw new Error(`فشل الطلب. حالة الخادم: ${response.status}`);
                        const data = await response.json();
                        if (Array.isArray(data)) {
                            TranslatorApp.dom.mappedIdsInput.value = JSON.stringify(data, null, 2);
                            TranslatorApp.ui.showAlert('تم جلب الأكواد بنجاح.', 'success');
                            TranslatorApp.state.hasUnsavedChanges = true;
                        } else {
                            throw new Error('البيانات ليست مصفوفة.');
                        }
                    } catch (error) {
                        console.error("Fetch Mapped IDs Error:", error);
                        TranslatorApp.ui.showAlert(`فشل الجلب بسبب قيود CORS. سيتم فتح الرابط للنسخ اليدوي.`, 'error', 8000);
                        window.open(url, '_blank');
                    }
                }
            },

            glossary: {
                add() {
                    const term = TranslatorApp.dom.glossaryTermInput.value.trim();
                    const translation = TranslatorApp.dom.glossaryTranslationInput.value.trim();
                    if (!term || !translation) return TranslatorApp.ui.showAlert('يرجى إدخال المصطلح وترجمته.', 'error');
                    if (TranslatorApp.state.glossary.some(e => e.term.toLowerCase() === term.toLowerCase())) return TranslatorApp.ui.showAlert('المصطلح موجود بالفعل.', 'error');
                    TranslatorApp.state.glossary.push({ term, translation, category: TranslatorApp.dom.glossaryCategory.value, dateAdded: new Date().toISOString() });
                    TranslatorApp.dom.glossaryTermInput.value = '';
                    TranslatorApp.dom.glossaryTranslationInput.value = '';
                    this.render();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                delete(index) { TranslatorApp.state.glossary.splice(index, 1); this.render(); TranslatorApp.state.hasUnsavedChanges = true; },
                render(filteredList = null) { const list = filteredList || TranslatorApp.state.glossary; TranslatorApp.ui.renderGlossaryList(list); },
                filter(searchTerm) {
                    const term = searchTerm.toLowerCase();
                    const filtered = TranslatorApp.state.glossary.filter(entry => entry.term.toLowerCase().includes(term) || entry.translation.toLowerCase().includes(term));
                    this.render(filtered);
                },
                export() {
                    if (TranslatorApp.state.glossary.length === 0) return TranslatorApp.ui.showAlert('القاموس فارغ.', 'error');
                    const escapeCSV = (str) => `"${(str || '').toString().replace(/"/g, '""')}"`;
                    let csvContent = '\uFEFF"term","translation"\r\n';
                    TranslatorApp.state.glossary.forEach(entry => { csvContent += `${escapeCSV(entry.term)},${escapeCSV(entry.translation)}\r\n`; });
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = 'translator_glossary.csv';
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                    TranslatorApp.ui.showAlert('تم تصدير القاموس بنجاح.', 'success');
                },
                async import(file) {
                    if (!file) return;
                    try {
                        const text = await file.text();
                        let imported = [];
                        const normalizeHeader = (h) => (h || '').toString().trim().replace(/^"|"$/g, '').toLowerCase();
                        const parseCsvLine = (line) => { const out = [], re = /("([^"]|"")*"|[^,]*)(,|$)/g; let m; while ((m = re.exec(line)) !== null) { let cell = (m[1] || '').replace(/^"|"$/g, '').replace(/""/g, '"'); out.push(cell); if (!m[3]) break; } return out; };
                        const isCsv = file.name.toLowerCase().endsWith('.csv') || /,/.test(text.split(/\r?\n/)[0] || '');
                        if (isCsv) {
                            const lines = text.split(/\r?\n/).filter(l => l.trim()); if (lines.length < 2) throw new Error('CSV فارغ.');
                            const headerCells = parseCsvLine(lines[0]).map(normalizeHeader);
                            const termIdx = headerCells.findIndex(h => ['term', 'source term', 'مصطلح'].includes(h));
                            const transIdx = headerCells.findIndex(h => ['translation', 'translated term', 'ترجمة'].includes(h));
                            if (termIdx === -1 || transIdx === -1) throw new Error('CSV يجب أن يحتوي أعمدة term و translation.');
                            imported = lines.slice(1).map(line => {
                                const cells = parseCsvLine(line);
                                const term = (cells[termIdx] || '').trim();
                                const translation = (cells[transIdx] || '').trim();
                                return { term, translation };
                            }).filter(r => r.term && r.translation);
                        } else {
                            const raw = JSON.parse(text);
                            if (!Array.isArray(raw)) throw new Error('JSON غير صالح.');
                            imported = raw.map(row => {
                                const term = (row.term || row['source term'] || row['مصطلح'] || '').toString().trim();
                                const translation = (row.translation || row['translated term'] || row['ترجمة'] || '').toString().trim();
                                return { term, translation };
                            }).filter(r => r.term && r.translation);
                        }
                        const newEntries = imported.filter(newEntry => !TranslatorApp.state.glossary.some(existing => existing.term.toLowerCase().trim() === newEntry.term.toLowerCase().trim()))
                            .map(e => ({ term: e.term, translation: e.translation, category: 'general', dateAdded: new Date().toISOString() }));
                        TranslatorApp.state.glossary = [...TranslatorApp.state.glossary, ...newEntries];
                        this.render();
                        TranslatorApp.state.hasUnsavedChanges = true;
                        TranslatorApp.ui.showAlert(`تم استيراد ${newEntries.length} مصطلح.`, 'success');
                    } catch (e) {
                        console.error(e);
                        TranslatorApp.ui.showAlert('فشل استيراد القاموس.', 'error');
                    } finally { TranslatorApp.dom.glossaryFileInput.value = ''; }
                }
            },

            subjects: {
                data: {
                    'None': { grades: ['None'], prompt: 'Translate to Arabic accurately. Preserve HTML/LaTeX and special placeholders (e.g., __LOCK_0__, __GLOSSARY_0__). If a text contains the separator \\n<SEP>\\n, translate each segment separately and preserve the separator exactly.' },
                    'Mathematics': {
                        grades: ['Grades 1–3', 'Grades 4–8', 'Grades 9–12'], prompts: {
                            'Grades 1–3': 'Task: Translate English Math questions for grades 1-3 into accurate, age-appropriate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use Arabic-Indic numerals.\n3) Write equations in LaTeX. Transliterate variables to Arabic (س، ص، ع).\n4) Fractions as \\dfrac{البسط}{المقام}.\n5) If text contains \\n<SEP>\\n, translate each part and preserve separator.',
                            'Grades 4–8': 'Task: Translate English Math questions for grades 4-8 into accurate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Translate units to Arabic abbreviations (cm→سم).\n4) Fractions as \\dfrac{numerator}{denominator}.\n5) If text contains \\n<SEP>\\n, translate each part and preserve separator.',
                            'Grades 9–12': 'Task: Translate English Math questions for grades 9-12 into accurate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use Arabic-Indic numerals; transliterate variables to Arabic.\n3) Fractions as \\dfrac{البسط}{المقام}.\n4) If text contains \\n<SEP>\\n, translate each part and preserve separator.'
                        }
                    },
                    'Physics': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Physics questions.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Keep physical formulas (e.g., F=ma), variables, and units (cm, m, kg) in their original LTR format. Wrap formulas in `<span dir="ltr"></span>`.\n4) Keep subscripts and variables exact.\n5) If text contains \\n<SEP>\\n, translate parts separately and preserve separator.'
                        }
                    },
                    'Chemistry': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Chemistry questions.\nRules:\n1) Use English numerals.\n2) Keep chemical formulas, symbols, and equations in their original LTR format. Wrap them in `<span dir="ltr"></span>` to ensure correct directionality.\n3) Keep units in English abbreviations.\n4) If text contains \\n<SEP>\\n, preserve separator.'
                        }
                    },
                    'Biology': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Biology questions.\nUse English numerals; Arabic labels (أ، ب، ج); translate text within figures; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Science': {
                        grades: ['Grades 4–8', 'Grade 9'], prompts: {
                            'Grades 4–8': 'Translate Science (4–8).\nUse English numerals; Arabic labels; chemical symbols in English; preserve \\n<SEP>\\n.',
                            'Grade 9': 'Translate Science (9).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Integrated Science': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Integrated Science.\nUse English numerals; Arabic labels; keep units; preserve \\n<SEP>\\n.'
                        }
                    },
                    'ICT': {
                        grades: ['Grade 4', 'Grade 5'], prompts: {
                            'Grade 4': 'Translate ICT (Grade 4).\nUse Arabic-Indic numerals; product names bilingual; preserve \\n<SEP>\\n.',
                            'Grade 5': 'Translate ICT (Grade 5).\nUse English numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Discover': {
                        grades: ['Grades 1–3'], prompts: {
                            'Grades 1–3': 'Translate Discover (1-3).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    }
                },
                init() { this.populateSubjects(); this.updateUI(); },
                populateSubjects() {
                    TranslatorApp.dom.subjectSelect.innerHTML = '';
                    Object.keys(this.data).forEach(subject => {
                        const opt = document.createElement('option'); opt.value = subject; opt.textContent = subject;
                        TranslatorApp.dom.subjectSelect.appendChild(opt);
                    });
                },
                populateGrades(subject) {
                    TranslatorApp.dom.gradeSelect.innerHTML = '';
                    const subjectData = this.data[subject];
                    if (subjectData && subjectData.grades) subjectData.grades.forEach(grade => {
                        const opt = document.createElement('option'); opt.value = grade; opt.textContent = grade;
                        TranslatorApp.dom.gradeSelect.appendChild(opt);
                    });
                },
                onSubjectChange() { const s = TranslatorApp.dom.subjectSelect.value; this.populateGrades(s); this.updatePromptPreview(); },
                onGradeChange() { this.updatePromptPreview(); },
                updatePromptPreview() { TranslatorApp.dom.promptPreview.value = this.buildSystemPrompt(); },
                getCurrentPrompt() {
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    if (subject === 'None' || !this.data[subject]) return this.data['None'].prompt;
                    return this.data[subject].prompts?.[grade] || Object.values(this.data[subject].prompts)[0] || '';
                },
                buildSystemPrompt() {
                    const base = this.getCurrentPrompt();
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    const wantArabic = TranslatorApp.quality.wantsArabicIndicDigits(subject, grade);
                    const digitsRule = wantArabic ? 'Use Arabic-Indic numerals (٠١٢٣٤٥٦٧٨٩).' : 'Use English numerals (0123456789).';
                    const core = [
                        // Move the critical rule to the top for emphasis
                        '**CRITICAL: Do NOT output any LaTeX commands for Arabic text. For example, the word "طالب" should be rendered exactly as "طالب" and NOT as "\\alt{\\ta}\\prime \\alt{\\alef}\\prime \\alt{\\la}\\prime \\alt{\\ba}\\prime".**',
                        'Core rules:',
                        '- Do NOT add or remove content.',
                        '- Translate text content inside of HTML tags. Preserve the HTML tags themselves (e.g., <table>, <b>, <img>) and all LaTeX markup exactly as-is.',
                        '- If a text segment contains no translatable prose (e.g., it is only a table of numbers, a chemical formula, or a URL), you MUST return the original text segment completely unchanged.',
                        '- If present, keep placeholders __LOCK_n__ and __GLOSSARY_n__ unchanged.',
                        `- ${digitsRule}`,
                        `- If text contains the separator ${TranslatorApp.constants.CONTEXT_SEPARATOR}, translate each segment and preserve the separator exactly.`,
                        '- Keep the order of choices unchanged.',
                        '- Output in Arabic (MSA), formal tone.'
                    ].join('\n');
                    return `${base}\n\n${core}`;
                },
                async apply() {
                    TranslatorApp.state.selectedSubject = TranslatorApp.dom.subjectSelect.value;
                    TranslatorApp.state.selectedGrade = TranslatorApp.dom.gradeSelect.value;
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showSubjectsModal(false);
                    TranslatorApp.ui.showAlert(`تم تطبيق: ${TranslatorApp.state.selectedSubject} - ${TranslatorApp.state.selectedGrade}`, 'success');
                },
                updateUI() {
                    TranslatorApp.dom.subjectSelect.value = TranslatorApp.state.selectedSubject;
                    this.populateGrades(TranslatorApp.state.selectedSubject);
                    TranslatorApp.dom.gradeSelect.value = TranslatorApp.state.selectedGrade;
                    this.updatePromptPreview();
                }
            },

            api: {
                abortController: null,
                createAbortController() { if (this.abortController) this.abortController.abort(); this.abortController = new AbortController(); return this.abortController; },
                cancel() { if (this.abortController) { this.abortController.abort(); TranslatorApp.ui.showAlert('تم إلغاء عملية الترجمة.', 'info'); TranslatorApp.state.isTranslating = false; TranslatorApp.ui.showScreen('setup'); } },

                async translateInChunks(jobs, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = jobs.length;
                    let done = 0;
                    jobs.forEach((job, idx) => job.uid = idx);

                    for (let i = 0; i < jobs.length; i += CHUNK_SIZE) {
                        const chunk = jobs.slice(i, i + CHUNK_SIZE);
                        const items = chunk.map(j => ({ id: j.uid, text: j.originalText }));
                        TranslatorApp.ui.updateProgress(`جاري الترجمة... (${Math.min(done + items.length, total)}/${total})`);
                        const outItems = await this.translateItemsBatch(items, apiKeyOrUrl, provider, localModelName, systemPrompt);
                        outItems.forEach(obj => {
                            const job = chunk.find(j => j.uid === obj.id);
                            if (!job) return;

                            // Get the translated text (which might still contain placeholders like __GLOSSARY_0__)
                            let translatedText = (obj.text || '').toString().trim();

                            // Revert the placeholders using the map we stored on the job object
                            if (job.placeholders) {
                                translatedText = TranslatorApp.remoteGlossary.revertPlaceholders(translatedText, job.placeholders);
                            }

                            // Use the REAL original text as the key for the cache
                            const cacheKey = job.realOriginalText || job.originalText;
                            TranslatorApp.state.translationCache.set(cacheKey, translatedText);
                        });
                        done += items.length;
                    }
                },

                async translateItemsBatch(items, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CONTEXT_SEPARATOR = TranslatorApp.constants.CONTEXT_SEPARATOR;
                    const userInstruction = `Translate all provided text to Modern Standard Arabic. Preserve HTML/LaTeX and placeholders.\nYou will receive a JSON object with an array "items": [{"id": number, "text": string}].\n- If "text" contains the exact separator "${CONTEXT_SEPARATOR}", translate each segment to Arabic and preserve the separator unchanged.\n- Preserve any HTML/LaTeX markup exactly.\n- Do NOT modify placeholders of the form __LOCK_n__ or __GLOSSARY_n__.\nReturn ONLY a valid JSON object: {"items":[{"id": number, "text": "translated"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;

                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    try {
                        const data = JSON.parse(responseText);
                        if (!data || !Array.isArray(data.items)) throw new Error('Invalid JSON structure from model.');
                        return data.items.map(x => ({ id: x.id, text: x.text }));
                    } catch (e) {
                        console.warn('JSON parse failed, falling back to delimiter mode.', e);
                        const BATCH_SEPARATOR = TranslatorApp.constants.BATCH_SEPARATOR;
                        const flat = items.map(it => `${it.id}:::${it.text}`).join(BATCH_SEPARATOR);
                        const fallbackPrompt = `${userInstruction}\nNow process items separated by "${BATCH_SEPARATOR}". Each starts with "<id>:::". Return ONLY valid JSON as specified.\n\n${flat}`;
                        let resp;
                        if (provider === 'gemini') resp = await this.withGeminiText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else if (provider === 'chatgpt') resp = await this.withChatGPTText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else resp = await this.withLocalModelText(systemPrompt, fallbackPrompt, apiKeyOrUrl, localModelName, signal);
                        const data2 = JSON.parse(resp);
                        if (!data2 || !Array.isArray(data2.items)) throw new Error('Invalid JSON structure from model (fallback).');
                        return data2.items.map(x => ({ id: x.id, text: x.text }));
                    }
                },

                async proofreadInChunks(items, apiKeyOrUrl, provider, localModelName = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = items.length;
                    let done = 0;
                    const allOut = [];
                    for (let i = 0; i < items.length; i += CHUNK_SIZE) {
                        const chunk = items.slice(i, i + CHUNK_SIZE);
                        TranslatorApp.ui.updateProgress(`تدقيق لغوي... (${Math.min(done + chunk.length, total)}/${total})`);
                        const out = await this.proofreadItemsBatch(chunk, apiKeyOrUrl, provider, localModelName);
                        allOut.push(...out);
                        done += chunk.length;
                    }
                    return allOut;
                },

                async proofreadItemsBatch(items, apiKeyOrUrl, provider, localModelName = '') {
                    const userInstruction = `You will receive JSON {"items":[{"id":number,"text":string}]}. Proofread Arabic grammar/style only.
- Do not add/remove content.
- Do not change digits, units, HTML, LaTeX, or any placeholders like __LOCK_n__ or __GLOSSARY_n__.
- Return ONLY {"items":[{"id":number,"text":"polished"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;
                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON('', userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    const data = JSON.parse(responseText);
                    return data.items;
                },

                async withGeminiJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });
                    if (!response.ok) { let err; try { err = await response.json(); } catch { } throw new Error(`Gemini API Error: ${err?.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = [];
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: `${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}` });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2, response_format: { type: "json_object" } })
                            });
                            if (!response.ok) {
                                let err; try { err = await response.json(); } catch { }
                                lastError = new Error(`ChatGPT API Error: ${err?.error?.message || response.statusText}`);
                                continue;
                            }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelJSON(systemPrompt, userInstruction, payload, url, modelName, signal) {
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}\n\nReturn ONLY JSON.`;
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: fullPrompt, system: '', stream: false, format: 'json' })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                },
                async withGeminiText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                    const fullPrompt = systemPrompt ? `${systemPrompt}\n\n---\n\n${userPrompt}` : userPrompt;
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = []; if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: userPrompt });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2 })
                            });
                            if (!response.ok) { const err = await response.json(); lastError = new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); continue; }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelText(systemPrompt, userPrompt, url, modelName, signal) {
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: userPrompt, system: systemPrompt, stream: false })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                }
            },

            history: {
                stack: [],
                currentIndex: -1,
                timeout: null,


                init() {
                    this.updateButtons();
                },

                push(state) {
                    const MAX_HISTORY = TranslatorApp.constants.HISTORY_MAX;
                    if (this.timeout) clearTimeout(this.timeout);

                    this.timeout = setTimeout(() => {
                        try {
                            this.stack = this.stack.slice(0, this.currentIndex + 1);
                            const snapshot = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                            this.stack.push(snapshot);

                            if (this.stack.length > MAX_HISTORY) {
                                this.stack.shift();
                            } else {
                                this.currentIndex++;
                            }

                            this.updateButtons();
                        } catch (error) {
                            console.error('History push error:', error);
                            // Reset history if there's an error
                            this.stack = [];
                            this.currentIndex = -1;
                            this.updateButtons();
                        }
                    }, 400);
                },

                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                redo() {
                    if (this.currentIndex < this.stack.length - 1) {
                        this.currentIndex++;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                restore(state) {
                    try {
                        TranslatorApp.state.translatedJsonData = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                        TranslatorApp.preview.render();
                        this.updateButtons();
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('History restore error:', error);
                        TranslatorApp.ui.showAlert('فشل في استعادة الحالة السابقة.', 'error');
                    }
                },

                updateButtons() {
                    TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                    TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
                },

            },
            // استبدال الدالة بالكامل بالنسخة الجديدة (تحليل HTML وتوليد مهام لعُقد النص)
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                let apiKeyOrUrl;
                let localModelName;
            
                try {
                    if (apiProvider === 'gemini') {
                        apiKeyOrUrl = this.dom.geminiKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'gemini')) {
                            return this.ui.showAlert(`مفتاح API لـ Gemini غير صالح.`, 'error');
                        }
                    } else if (apiProvider === 'chatgpt') {
                        apiKeyOrUrl = this.dom.chatgptKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'chatgpt')) {
                            return this.ui.showAlert(`مفتاح API لـ ChatGPT غير صالح.`, 'error');
                        }
                    } else if (apiProvider === 'local') {
                        apiKeyOrUrl = this.dom.localModelUrl.value.trim();
                        localModelName = this.dom.localModelName.value.trim();
                        const validation = this.validation.validateLocalModelSettings(apiKeyOrUrl, localModelName);
                        if (!validation.valid) {
                            return this.ui.showAlert(validation.message, 'error');
                        }
                    } else {
                        return this.ui.showAlert('يرجى اختيار مزود خدمة صالح.', 'error');
                    }
            
                    if (this.state.selectedFilesInfo.length === 0) {
                        return this.ui.showAlert('اختر ملف JSON واحد على الأقل.', 'error');
                    }
                } catch (validationError) {
                    return this.ui.showAlert('خطأ في التحقق من صحة البيانات المدخلة.', 'error');
                }
            
                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear();
                this.state.startTime = Date.now();
                this.api.createAbortController();
                this.state.isTranslating = true;
            
                try {
                    this.ui.updateProgress('جاري قراءة الملفات...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));
            
                    const allJobs = [];
                    const parsedDataMap = new Map();
            
                    const processField = (htmlString, basePointer) => {
                        if (!htmlString || typeof htmlString !== 'string') return;
                        const { jobs, parsedBody } = this.utils.parseHtmlAndCreateJobs(htmlString, basePointer);
                        allJobs.push(...jobs);
                        const mapKey = JSON.stringify(basePointer);
                        parsedDataMap.set(mapKey, parsedBody);
                    };
                    
                    this.ui.updateProgress('جاري تحليل المحتوى وتجهيز النصوص...');
            
                    this.state.originalJsonData.forEach((file, fileIndex) => {
                        // Process statement field
                        processField(file.data.statement, { fileIndex, key: 'statement' });
                        
                        // Process parts
                        file.data.parts?.forEach((part, partIndex) => {
                            const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                            
                            // Process stem field
                            processField(part.stem, { fileIndex, partIndex, key: 'stem' });
            
                            // Process answer field
                            if (originalPart.answer) {
                                if (Array.isArray(originalPart.answer)) {
                                    originalPart.answer.forEach((answerItem, answerIndex) => {
                                        processField(answerItem, { fileIndex, partIndex, answerIndex, key: 'answer', isArray: true });
                                    });
                                } else if (typeof originalPart.answer === 'string') {
                                    processField(originalPart.answer, { fileIndex, partIndex, key: 'answer' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('key') && originalPart.answer.hasOwnProperty('value') && originalPart.answer.hasOwnProperty('unit')) {
                                    // Special case for a more complex object answer type
                                    processField(originalPart.answer.key, { fileIndex, partIndex, key: 'answer', subKey: 'key' });
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                    processField(originalPart.answer.unit, { fileIndex, partIndex, key: 'answer', subKey: 'unit' });
                                }
                            }
                            
                            // Process choices
                            originalPart.choices?.forEach((choice, choiceIndex) => {
                                processField(choice.html_content, { fileIndex, partIndex, choiceIndex, key: 'choice' });
                            });
                            
                            // Process gap_text_keys
                            if (originalPart.gap_text_keys) {
                                originalPart.gap_text_keys.forEach((keyItem, keyIndex) => {
                                    processField(keyItem.value, { fileIndex, partIndex, key: 'gap_text_keys', keyIndex: keyIndex, subKey: 'value' });
                                });
                            }
                        });
                    });
                    
                    const uniqueJobs = [];
                    const seen = new Set();
                    for (const job of allJobs) {
                        if (!seen.has(job.originalText)) {
                            seen.add(job.originalText);
                            uniqueJobs.push(job);
                        }
                    }
                    
                    this.ui.updateProgress('جاري جلب المصطلحات المعتمدة...');
                    const allTextsForGlossary = uniqueJobs.map(j => j.originalText);
                    await this.remoteGlossary.fetchApproved(this.state.selectedSubject, allTextsForGlossary);
            
                    uniqueJobs.forEach(job => {
                        const { modifiedText, placeholders } = this.remoteGlossary.applyWithPlaceholders(job.originalText);
                        job.realOriginalText = job.originalText;
                        job.originalText = modifiedText;
                        job.placeholders = placeholders;
                    });
            
                    if (uniqueJobs.length > 0) {
                        this.ui.updateProgress(`جاري ترجمة ${uniqueJobs.length} نص فريد...`);
                        const systemPrompt = this.subjects.buildSystemPrompt();
                        await this.api.translateInChunks(uniqueJobs, apiKeyOrUrl, apiProvider, localModelName, systemPrompt);
                    }
            
                    this.ui.updateProgress('جاري إعادة بناء المحتوى المترجم...');
            
                    allJobs.forEach(job => {
                        const cacheKey = job.realOriginalText || job.originalText;
                        let translatedText = this.state.translationCache.get(cacheKey);
                        if (translatedText && job.domNode) {
                            translatedText = this.quality.cleanLatexArabic(translatedText);
                            job.domNode.nodeValue = translatedText;
                        }
                    });
            
                    for (const [mapKey, parsedBody] of parsedDataMap.entries()) {
                        const pointer = JSON.parse(mapKey);
                        const finalHtml = parsedBody.innerHTML;
                        const cleanedHtml = TranslatorApp.quality.cleanLatexArabic(finalHtml);
                        const { fileIndex, partIndex, choiceIndex, key, keyIndex, subKey, answerIndex, isArray } = pointer;
                        let target = this.state.translatedJsonData[fileIndex].data;
            
                        if (key === 'statement') {
                            target.statement = cleanedHtml;
                        } else if (key === 'stem') {
                            target.parts[partIndex].stem = cleanedHtml;
                        } else if (key === 'answer') {
                            if (isArray) { // Check if the original was an array
                                if (target.parts?.[partIndex]?.answer && target.parts[partIndex].answer.length > answerIndex) {
                                     target.parts[partIndex].answer[answerIndex] = cleanedHtml;
                                }
                            } else if (subKey === 'value') {
                                target.parts[partIndex].answer.value = cleanedHtml;
                            } else if (subKey === 'key') {
                                 target.parts[partIndex].answer.key = cleanedHtml;
                            } else if (subKey === 'unit') {
                                 target.parts[partIndex].answer.unit = cleanedHtml;
                            } else {
                                target.parts[partIndex].answer = cleanedHtml;
                            }
                        } else if (key === 'choice') {
                            target.parts[partIndex].choices[choiceIndex].html_content = cleanedHtml;
                        } else if (key === 'gap_text_keys' && subKey === 'value') {
                            if (target.parts[partIndex].gap_text_keys && target.parts[partIndex].gap_text_keys[keyIndex]) {
                                target.parts[partIndex].gap_text_keys[keyIndex].value = cleanedHtml;
                            }
                        }
                    }
            
                    this.state.activeScreen = 'preview';
                    this.history.push(this.state.translatedJsonData);
                    this.session.save();
                    this.ui.showScreen('preview');
                    this.preview.render();
                    const stats = this.statistics.calculate();
                    this.ui.renderStatistics(stats);
                    this.ui.showAlert('تمت الترجمة بنجاح', 'success');
            
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.error('Translation process failed:', error);
                        this.ui.showAlert(error.message, 'error');
                        this.ui.showScreen('setup');
                    }
                } finally {
                    this.dom.translateBtn.disabled = false;
                    this.state.isTranslating = false;
                }
            },

            statistics: {
                calculate() {
                    let totalTexts = 0, totalWords = 0;
                    const count = (text) => {
                        if (text && typeof text === 'string') {
                            totalTexts++;
                            const div = document.createElement('div'); div.innerHTML = text;
                            totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                        }
                    };
                    TranslatorApp.state.originalJsonData.forEach(file => {
                        count(file.data.statement);
                        file.data.parts?.forEach(part => {
                            count(part.stem);
                            if (typeof part.answer === 'string') count(part.answer);
                            part.choices?.forEach(choice => count(choice.html_content));
                            part.gap_text_keys?.forEach(keyItem => count(keyItem.value));
                        });
                    });
                    const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                    return { totalFiles: TranslatorApp.state.selectedFilesInfo.length, totalTexts, totalWords, timeElapsed };
                }
            },

            ui: {
                showScreen(screen) {
                    try {
                        TranslatorApp.state.activeScreen = screen;
                        ['setupSection', 'progressContainer', 'previewSection', 'analyticsSection'].forEach(id => {
                            try {
                                TranslatorApp.dom[id]?.classList.add('hidden');
                            } catch (error) {
                                console.warn(`Error hiding ${id}:`, error);
                            }
                        });

                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.setupSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing setup section:', error);
                            }
                        }
                        if (screen === 'progress') {
                            try {
                                TranslatorApp.dom.progressContainer.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing progress container:', error);
                            }
                        }
                        if (screen === 'preview') {
                            try {
                                TranslatorApp.dom.previewSection.classList.remove('hidden');
                                TranslatorApp.dom.analyticsSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing preview section:', error);
                            }
                        }

                        // Reset any error states
                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.translateBtn.disabled = false;
                                TranslatorApp.state.isTranslating = false;
                            } catch (error) {
                                console.warn('Error resetting translate button:', error);
                            }
                        }
                    } catch (error) {
                        console.error('Show screen error:', error);
                    }
                },
                updateProgress(text) {
                    try {
                        TranslatorApp.dom.progressText.textContent = text;
                    } catch (error) {
                        console.error('Update progress error:', error);
                    }
                },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500', warning: 'bg-yellow-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;

                    // Sanitize message to prevent XSS
                    const sanitizedMessage = TranslatorApp.security.sanitize(message);
                    alertBox.innerHTML = `<span>${sanitizedMessage}</span><button class="mr-2 text-xl font-bold" aria-label="إغلاق">&times;</button>`;

                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);

                    // Auto-remove after duration
                    if (duration) {
                        setTimeout(() => {
                            alertBox.classList.add('fade-out');
                            alertBox.addEventListener('transitionend', () => alertBox.remove());
                        }, duration);
                    }

                    // Log to console for debugging
                    console.log(`[${type.toUpperCase()}] ${message}`);
                },
                renderFileList() {
                    try {
                        const { fileList } = TranslatorApp.dom;
                        fileList.innerHTML = '';
                        if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                        const ul = document.createElement('ul');
                        ul.className = 'my-4 space-y-2';
                        TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between items-center p-2 rounded-lg';
                            li.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 5%, var(--card-bg))';
                            li.innerHTML = `<span class="font-medium">${TranslatorApp.security.sanitize(fileInfo.name)}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl" aria-label="إزالة">&times;</button>`;
                            ul.appendChild(li);
                        });
                        fileList.appendChild(ul);
                        fileList.querySelectorAll('.remove-file-btn').forEach(btn => {
                            btn.onclick = (e) => {
                                try {
                                    TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index));
                                } catch (error) {
                                    console.error('Remove file error:', error);
                                    TranslatorApp.ui.showAlert('فشل في إزالة الملف.', 'error');
                                }
                            };
                        });
                    } catch (error) {
                        console.error('Render file list error:', error);
                        TranslatorApp.ui.showAlert('فشل في عرض قائمة الملفات.', 'error');
                    }
                },
                showGlossaryModal(show) {
                    try {
                        TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show glossary modal error:', error);
                    }
                },
                showMappedIdsModal(show) {
                    try {
                        TranslatorApp.dom.mappedIdsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show mapped IDs modal error:', error);
                    }
                },
                showSubjectsModal(show) {
                    try {
                        TranslatorApp.dom.subjectsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show subjects modal error:', error);
                    }
                },
                showModal(id, show) {
                    try {
                        const el = TranslatorApp.dom[id];
                        if (el) el.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show modal error:', error);
                    }
                },
                renderGlossaryList(list) {
                    try {
                        const c = TranslatorApp.dom.glossaryListContainer;
                        c.innerHTML = '';
                        if (list.length === 0) {
                            c.innerHTML = `<p class="text-center" style="color: var(--secondary-text)">لا توجد مصطلحات.</p>`;
                            return;
                        }
                        const ul = document.createElement('ul');
                        ul.className = 'space-y-2';
                        list.forEach((entry) => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between items-center p-2 rounded-md border';
                            li.style.backgroundColor = 'var(--card-bg)';
                            li.style.borderColor = 'var(--card-border)';
                            const originalIndex = TranslatorApp.state.glossary.findIndex(g => g.term === entry.term);
                            li.innerHTML = `
                    <div>
                            <span class="font-semibold">${TranslatorApp.security.sanitize(entry.term)}</span>
                        <span class="mx-2" style="color: var(--secondary-text)">→</span>
                            <span>${TranslatorApp.security.sanitize(entry.translation)}</span>
                        <span class="text-xs mr-2 px-2 py-1 rounded-full" style="background-color: var(--bg-color);">${entry.category || 'عام'}</span>
                    </div>
                    <button data-index="${originalIndex}" class="remove-glossary-btn text-red-500 hover:text-red-700 font-bold" aria-label="حذف">&times;</button>`;
                            ul.appendChild(li);
                        });
                        c.appendChild(ul);
                        c.querySelectorAll('.remove-glossary-btn').forEach(btn => btn.onclick = (e) => {
                            try {
                                TranslatorApp.glossary.delete(parseInt(btn.dataset.index));
                            } catch (error) {
                                console.error('Remove glossary term error:', error);
                                TranslatorApp.ui.showAlert('فشل في حذف المصطلح.', 'error');
                            }
                        });
                    } catch (error) {
                        console.error('Render glossary list error:', error);
                        TranslatorApp.ui.showAlert('فشل في عرض قائمة المصطلحات.', 'error');
                    }
                },
                renderStatistics(stats) {
                    try {
                        const { statsContainer } = TranslatorApp.dom;
                        statsContainer.innerHTML = '';
                        const map = {
                            'إجمالي الملفات': stats.totalFiles,
                            'إجمالي النصوص': stats.totalTexts,
                            'إجمالي الكلمات': stats.totalWords,
                            'زمن الترجمة (ث)': stats.timeElapsed
                        };
                        Object.entries(map).forEach(([label, value]) => {
                            const card = document.createElement('div');
                            card.className = 'p-4 rounded-lg';
                            card.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 10%, var (--card-bg))';
                            card.innerHTML = `<div class="text-2xl font-bold" style="color: var (--primary-color);">${value}</div><div class="text-sm" style="color: var (--secondary-text);">${label}</div>`;
                            statsContainer.appendChild(card);
                        });
                    } catch (error) {
                        console.error('Render statistics error:', error);
                    }
                },
                setSaveIndicator(state) {
                    try {
                        const el = TranslatorApp.dom.saveIndicator;
                        if (!el) return;

                        if (state === 'saving') {
                            el.textContent = 'جاري الحفظ...';
                            el.classList.remove('saved', 'error');
                        }
                        else if (state === 'saved') {
                            el.textContent = '✓ محفوظ';
                            el.classList.add('saved');
                            el.classList.remove('error');
                            setTimeout(() => {
                                el.textContent = '—';
                                el.classList.remove('saved');
                            }, 2000);
                        }
                        else if (state === 'error') {
                            el.textContent = '✗ خطأ في الحفظ';
                            el.classList.add('error');
                            el.classList.remove('saved');
                        }
                        else {
                            el.textContent = '—';
                            el.classList.remove('saved', 'error');
                        }
                    } catch (error) {
                        console.error('Save indicator error:', error);
                    }
                }
            },

            preview: {
                dmp: new diff_match_patch(),

                renderContentWithMath(htmlString) {
                    try {
                        if (typeof htmlString !== 'string' || !htmlString) {
                            return '<div class="content-root" dir="rtl">&nbsp;</div>';
                        }
                        const cleanedHtml = htmlString.replace(/R\s*(\d+)/g, 'والباقي $1');

                        // 1. Sanitize the incoming HTML first
                        let sanitizedHtml = TranslatorApp.security.sanitize(cleanedHtml); // use cleanedHtml here
                        // 2. Create a temporary DOM element to parse the sanitized HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = sanitizedHtml;
                
                        // 3. Use a TreeWalker to process all nodes and convert LaTeX
                        const walker = document.createTreeWalker(
                            tempDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        const nodesToReplace = [];
                        let node;
                        while ((node = walker.nextNode())) {
                            let textContent = node.textContent;

                            // Find and replace LaTeX expressions
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    const isDisplayMode = part.startsWith('$$') && part.endsWith('$$');
                                    const isInlineMode = part.startsWith('$') && part.endsWith('$');
                
                                    if (isDisplayMode || isInlineMode) {
                                        const latex = part.slice(isDisplayMode ? 2 : 1, isDisplayMode ? -2 : -1);

                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', isDisplayMode ? 'math' : 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                    
                                        // Create the delete button and add it directly to the math-field
                                        const deleteBtn = document.createElement('button');
                                        deleteBtn.className = 'math-field-delete-btn';
                                        deleteBtn.textContent = '×';
                                        deleteBtn.title = 'حذف المعادلة';
                                        deleteBtn.onclick = (event) => {
                                            event.stopPropagation();
                                            const fieldContainer = mf.closest('.editable-preview-field');
                                            mf.remove(); // This removes the math field itself
                                            if (fieldContainer) {
                                                TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                            }
                                        };
                                        mf.appendChild(deleteBtn);
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        let finalHtml = tempDiv.innerHTML;
                        finalHtml = this.decorateBlanks(finalHtml);
                        finalHtml = this.injectChemistryMathFields(finalHtml);
                        finalHtml = TranslatorApp.utils.textDirection.enhancePreviewContent(finalHtml);
                
                        const textContent = tempDiv.textContent || '';
                        const containerDirection = TranslatorApp.utils.textDirection.getDominantDirection(textContent);
                        const dirAttr = containerDirection === 'rtl' ? 'rtl' : 'ltr';
                
                        return `<div class="content-root" dir="${dirAttr}">${finalHtml}</div>`;
                    } catch (error) {
                        console.error('Render content with math error:', error);
                        return '<div class="content-root" dir="rtl">فشل في عرض المحتوى</div>';
                    }
                },
                    
                handleCopyEvent(e) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;
                
                    const range = selection.getRangeAt(0);
                    const clonedContent = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(clonedContent);
                
                    const mathFields = tempDiv.querySelectorAll('math-field');
                    mathFields.forEach(mf => {
                        const mode = mf.getAttribute('default-mode');
                        const value = mf.value;
                        const delimiter = (mode === 'math') ? '$$' : '$';
                        const latexString = `${delimiter}${value}${delimiter}`;
                        
                        const textNode = document.createTextNode(latexString);
                        mf.parentNode.replaceChild(textNode, mf);
                    });
                    const html = tempDiv.innerHTML;
                    const text = tempDiv.textContent || '';
                    
                    e.clipboardData.setData('text/html', html);
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                    
                },

                handlePasteEvent(e) {
                    try {
                        e.preventDefault();
                        const pasteHtml = e.clipboardData.getData('text/html');
                        const pasteText = e.clipboardData.getData('text/plain');
                        let contentToInsert = '';
                        if (pasteHtml) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = pasteHtml;
                            contentToInsert = tempDiv.innerHTML;
                        } else {
                            contentToInsert = pasteText;
                        }
                        if (!contentToInsert) return;

                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        const processorDiv = document.createElement('div');
                        processorDiv.innerHTML = contentToInsert;
                        const walker = document.createTreeWalker(
                            processorDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        let node;
                        const nodesToReplace = [];
                        
                        while ((node = walker.nextNode())) {
                            const textContent = node.textContent;
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                            
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    if (part.startsWith('$$') && part.endsWith('$$')) {
                                        const latex = part.slice(2, -2);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part.startsWith('$') && part.endsWith('$')) {
                                        const latex = part.slice(1, -1);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        const finalFragment = document.createDocumentFragment();
                        while (processorDiv.firstChild) {
                            finalFragment.appendChild(processorDiv.firstChild);
                        }
                        range.insertNode(finalFragment);
                        selection.collapseToEnd();
                        
                        const fieldContainer = e.target.closest('.editable-preview-field');
                        if (fieldContainer) {
                            this.handlePreviewFieldUpdate(fieldContainer);
                        }
                    } catch (error) {
                        console.error('Paste event error:', error);
                        TranslatorApp.ui.showAlert('Paste failed. Plain text copied instead.', 'error');
                        document.execCommand('insertText', false, e.clipboardData.getData('text/plain'));
                    }
                    
                },      

                // Convert plain chemical formulas (e.g., NaHCO3, H2SO4, Ca(OH)2) into inline math-fields
                injectChemistryMathFields(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        const escapeAttr = (s) => (s || '').replace(/"/g, '&quot;');
                        // Basic LaTeX conversion: element digits -> _{digits}, parenthesis digits -> _{digits}
                        const toLatex = (formula) => {
                            try {
                                let out = formula;
                                out = out.replace(/([A-Za-z][a-z]?)\s*(\d+)/g, '$1_{$2}');
                                out = out.replace(/\)(\d+)/g, ')_{$1}');
                                return out;
                            } catch (error) {
                                console.warn('LaTeX conversion error:', error);
                                return formula;
                            }
                        };
                        // Regex for typical chemical formula tokens
                        const chemRegex = /\b(?:[A-Z][a-z]?\d*)+(?:\([A-Za-z\d]+\)\d*)*\b/g;
                        return text.replace(chemRegex, (match) => {
                            try {
                                // Avoid converting if already inside an HTML tag like <span> or attributes
                                // Heuristic: skip if match is immediately preceded by '&' (entity) or within a tag
                                // Since we sanitize later and we run on plain text chunks, this is usually safe
                                const latex = escapeAttr(toLatex(match));
                                return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                            } catch (error) {
                                console.warn('Chemistry field injection error:', error);
                                return match;
                            }
                        });
                    } catch (error) {
                        console.error('Inject chemistry math fields error:', error);
                        return text;
                    }
                },

                decorateBlanks(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        // Replace sequences of 3+ underscores with a visual blank slot
                        // Also handle other common blank patterns like [___], (___), etc.
                        let decorated = text;

                        // Detect text direction for appropriate blank styling
                        const textDirection = TranslatorApp.utils.textDirection.getDominantDirection(text);
                        const isMixed = TranslatorApp.utils.textDirection.isMixed(text);
                        const directionClass = isMixed ? 'mixed-content' : (textDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');

                        // Handle underscores: ___, ____, _____ etc.
                        decorated = decorated.replace(/_{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'_'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}"></span>`);

                        // Handle brackets with underscores: [___], (___), {___}
                        decorated = decorated.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                            const underscores = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}">${underscores}</span>${close}`;
                        });

                        // Handle simple brackets with spaces: [   ], (   ), {   }
                        decorated = decorated.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                            const spaces = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${spaces}" dir="${isMixed ? 'auto' : textDirection}">${spaces}</span>${close}`;
                        });

                        // Handle other common blank patterns
                        // Handle question marks: ???, ???? etc.
                        decorated = decorated.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'?'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dashes: ---, ---- etc.
                        decorated = decorated.replace(/-{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'-'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dots: ..., .... etc.
                        decorated = decorated.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'.'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle HTML content with blanks (preserve HTML structure)
                        if (decorated.includes('<') && decorated.includes('>')) {
                            // Create a temporary DOM element to process HTML content
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = decorated;

                            // Process text nodes within HTML
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            // Process each text node
                            textNodes.forEach(textNode => {
                                const originalText = textNode.textContent;
                                let processedText = originalText;

                                // Detect direction for this specific text node
                                const nodeDirection = TranslatorApp.utils.textDirection.getDominantDirection(originalText);
                                const nodeIsMixed = TranslatorApp.utils.textDirection.isMixed(originalText);
                                const nodeDirectionClass = nodeIsMixed ? 'mixed-content' : (nodeDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');
                                const nodeDir = nodeIsMixed ? 'auto' : nodeDirection;

                                // Apply blank decoration to text content with proper direction
                                processedText = processedText.replace(/_{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'_'.repeat(m.length)}" dir="${nodeDir}"></span>`);
                                processedText = processedText.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                                    const underscores = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}">${underscores}</span>${close}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                                    const spaces = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${spaces}" dir="${nodeDir}">${spaces}</span>${close}`;
                                });
                                processedText = processedText.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'?'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/-{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'-'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'.'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);

                                if (processedText !== originalText) {
                                    const wrapper = document.createElement('span');
                                    wrapper.innerHTML = processedText;
                                    // Apply direction to the wrapper as well
                                    TranslatorApp.utils.textDirection.applySmartDirection(wrapper, originalText);
                                    textNode.parentNode.replaceChild(wrapper, textNode);
                                }
                            });

                            decorated = tempDiv.innerHTML;
                        }

                        return decorated;
                    } catch (error) {
                        console.error('Decorate blanks error:', error);
                        return text;
                    }
                },

                handleUnitUpdate(fieldContainer, newUnitValue) {
                    try {
                        if (!fieldContainer) return;
                
                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data for unit update:', { path, fileIndex });
                            return;
                        }
                
                        const pathParts = path.split('.');
                        const parentPath = pathParts.slice(0, pathParts.length - 1);
                        let targetObject = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        for (const key of parentPath) {
                            targetObject = targetObject[key];
                        }
                
                        if (targetObject && typeof targetObject === 'object' && targetObject.hasOwnProperty('unit')) {
                            targetObject.unit = newUnitValue;
                        }
                        
                        this.updateDiff(fileIndex, path, newUnitValue);
                
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'تم التعديل يدوياً';
                        }
                        
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Handle unit update error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث وحدة الإجابة.', 'error');
                    }
                },
                // New helper function to get data by path
                getDataByPath(obj, path) {
                    return path.split('.').reduce((o, i) => (o ? o[i] : undefined), obj);
                },

                handlePreviewFieldUpdate(fieldContainer) {
                    try {
                        if (!fieldContainer) return;

                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data:', { path, fileIndex });
                            return;
                        }
                        let newContent = '';
                        const root = fieldContainer.querySelector('.content-root');
                        if (root) {
                            root.childNodes.forEach(node => {
                                if (node.tagName === 'MATH-FIELD') {
                                    const delimiter = node.getAttribute('default-mode') === 'math' ? '$$' : '$';
                                    newContent += `${delimiter}${node.value}${delimiter}`;
                                } else {
                                    newContent += node.outerHTML || node.textContent;
                                }
                            });
                        }
                        
                        // Remove the visual blank slots from the final HTML before saving
                        newContent = newContent.replace(/<span class="blank-slot"[^>]*><\/span>/g, '___');
                        this.updateData(fileIndex, path, newContent);
                        this.updateDiff(fileIndex, path);
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'تم التعديل يدوياً';
                        }

                        // Push to history after update is complete
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;

                    } catch (error) {
                        console.error('Handle preview field update error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث حقل المعاينة.', 'error');
                    }
                },

                render() {
                    try {
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '';
                        
                        // Get the mapped IDs from the input field once before the loop
                        let mappedIdsArray = [];
                        try {
                            if (TranslatorApp.dom.useMappedIdsCheckbox.checked && TranslatorApp.dom.mappedIdsInput.value.trim()) {
                                mappedIdsArray = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            }
                        } catch (e) {
                            console.error('Error parsing mapped IDs from input:', e);
                            TranslatorApp.ui.showAlert('قائمة المعرفات (mapped_id) غير صالحة. يرجى التأكد من أنها مصفوفة JSON صحيحة.', 'error');
                        }
                
                        TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                            try {
                                const fileAccordion = document.createElement('div');
                                fileAccordion.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                
                                const header = document.createElement('button');
                                header.className = 'accordion-header';
                                
                                const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id || file.name.replace('.json', '');
                                const currentMappedId = mappedIdsArray[fileIndex] || null;
                
                                // Construct the header HTML with both IDs and their labels
                                const headerHtml = `
                                    <div style="display: flex; justify-content: space-between; width: 100%; align-items: center;">
                                        <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Original ID:</span>
                                        <span dir="ltr" style="font-family: monospace;">${originalId}</span>
                                        ${currentMappedId ? `
                                        <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Mapped ID:</span>
                                        <span dir="ltr" style="font-family: monospace;">${currentMappedId}</span>
                                        ` : ''}
                                    </div>
                                `;
                
                                header.innerHTML = `
                                    <div style="display: flex; justify-content: space-between; width: 100%; align-items: center;">
                                        <div style="display: flex; align-items: center;">
                                            <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Original ID:</span>
                                            <span dir="ltr" style="font-family: monospace; margin-left: 8px;">${originalId}</span>
                                        </div>
                                        ${currentMappedId ? `
                                        <div style="display: flex; align-items: center;">
                                            <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Mapped ID:</span>
                                            <span dir="ltr" style="font-family: monospace; margin-left: 8px;">${currentMappedId}</span>
                                        </div>
                                        ` : ''}
                                    </div>
                                `;
                
                                header.onclick = (e) => {
                                    const content = e.currentTarget.nextElementSibling;
                                    const accordionParent = e.currentTarget.closest('.preview-card');
                                    const isOpen = content.style.maxHeight && content.style.maxHeight !== '0px';
                                    
                                    if (isOpen) {
                                        content.style.maxHeight = null;
                                        accordionParent.style.boxShadow = null;
                                        accordionParent.style.transform = null;
                                        accordionParent.classList.remove('open');
                                    } else {
                                        content.style.maxHeight = content.scrollHeight + "px";
                                        accordionParent.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
                                        accordionParent.style.transform = 'scale(1.01)';
                                        accordionParent.classList.add('open');
                                    }
                                };
                                
                                const content = document.createElement('div');
                                content.className = 'accordion-content';
                                content.innerHTML = this.renderFileContent(file.data, fileIndex, currentMappedId);
                
                                fileAccordion.appendChild(header);
                                fileAccordion.appendChild(content);
                                previewContainer.appendChild(fileAccordion);
                
                                this.generateInitialDiffs(fileIndex);
                            } catch (fileError) {
                                console.warn('Error rendering file:', fileError);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                                errorDiv.innerHTML = `<div class="p-4" style="color: var(--error-color);">خطأ في عرض الملف: ${file.name}</div>`;
                                previewContainer.appendChild(errorDiv);
                            }
                        });
                        this.prepareInteractiveMathFields();
                    } catch (error) {
                        console.error('Preview render error:', error);
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '<div class="p-4" style="color: var(--error-color);">فشل في عرض المعاينة</div>';
                    }
                },
                renderReadOnlyField(label, originalValue, translatedValue) {
                    try {
                        if (originalValue === undefined || originalValue === null) return '';
                        const displayOriginalValue = Array.isArray(originalValue) ? originalValue.join(', ') : String(originalValue);
                        const displayTranslatedValue = Array.isArray(translatedValue) ? translatedValue.join(', ') : String(translatedValue);
                        
                        // This is a new check for numeric values to determine direction, but it's not applied correctly.
                        // const isNumeric = !isNaN(parseFloat(displayOriginalValue)) && isFinite(displayOriginalValue);
                        // const dirAttr = isNumeric ? 'ltr' : 'rtl'; 
                        
                        // Let's assume the original values are always English and force LTR for them.
                        const originalDir = 'ltr'; 
                
                        const enhancedOriginal = TranslatorApp.utils.textDirection.enhancePreviewContent(displayOriginalValue);
                        const enhancedTranslated = TranslatorApp.utils.textDirection.enhancePreviewContent(displayTranslatedValue);
                
                        return `
                            <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="${originalDir}" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedOriginal}</div>
                                    </div>
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedTranslated}</div>
                                    </div>
                                </div>
                            </div>`;
                    } catch (error) {
                        console.error('Render read only field error:', error);
                        return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <h5 class="font-bold flex items-center mb-2">خطأ في العرض</h5>
                            <div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">فشل في عرض المحتوى</div>
                        </div>`;
                    }
                },
                renderInputField(label, originalValue, translatedValue, originalUnit, translatedUnit, path, fileIndex) {
                    if (originalValue === undefined || originalValue === null) return '';
                
                    const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                    const statusId = `status-${fieldId}`;
                
                    // Get the translated unit from the new map
                    const translatedUnitText = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                
                    return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <div class="flex justify-between items-center mb-2">
                                <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="تمت الترجمة"></span></h5>
                                <div class="flex gap-2">
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">نسخ الأصلي</button>
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('diff-field-${fileIndex}-${path.replace(/\./g, '-')}').parentNode.classList.toggle('hidden')">عرض/إخفاء الفروقات</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                    <div class="original-text-readonly p-3 rounded-lg text-sm h-full flex items-center justify-end" style="background-color: var(--bg-color); color: var(--secondary-text); overflow:auto;">
                                        <span dir="ltr">${TranslatorApp.security.sanitize(originalValue)}</span>
                                        <span dir="ltr" class="mr-2">${TranslatorApp.security.sanitize(originalUnit)}</span>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                    <div id="${fieldId}" 
                                        class="editable-preview-field flex items-center justify-end"
                                        data-path="${path}"
                                        data-file-index="${fileIndex}"
                                        dir="rtl">
                                        <span contenteditable="true" dir="ltr" class="flex-grow text-right">${TranslatorApp.security.sanitize(translatedValue)}</span>
                                        <span contenteditable="true" dir="rtl" class="flex-shrink-0 mr-2 editable-unit">${TranslatorApp.security.sanitize(translatedUnitText)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4 hidden">
                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">مقارنة الفروقات</p>
                                <div id="diff-field-${fileIndex}-${path.replace(/\./g, '-')}" class="diff-view"></div>
                            </div>
                        </div>
                    `;
                },
                        
                renderReadOnlyLTRField(label, value) {
                    if (value === undefined || value === null) return '';
                    const displayValue = Array.isArray(value) ? value.join(', ') : String(value);
                
                    return `
                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                        <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                        <div>
                            <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                            <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(displayValue)}</div>
                        </div>
                    </div>`;
                },

                renderFileContent(data, fileIndex, mappedId) {
                    try {
                        let html = '<div class="space-y-6">';
                
                        const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id;
                
                        // Display both original and mapped IDs with labels
                        if (originalId) {
                            html += `<div class="p-4 bg-gray-100 rounded-lg shadow-inner mb-4 flex items-center justify-between">
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">original_id:</span> <span dir="ltr" style="font-family: monospace;">${originalId}</span>
                                </div>`;
                            
                            // Show mapped_id if it exists
                            if (mappedId) {
                                html += `
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">mapped_id:</span> <span dir="ltr" style="font-family: monospace;">${mappedId}</span>
                                </div>`;
                            }
                            html += `</div>`;
                        }
                
                        const renderField = (label, originalValue, translatedValue, path, editableDir = 'rtl') => {
                            try {
                                if (originalValue === undefined || originalValue === null || (Array.isArray(originalValue) && originalValue.length === 0)) {
                                    return '';
                                }
                                const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                                const diffId = `diff-${fieldId}`;
                                const statusId = `status-${fieldId}`;
                                
                                const displayOriginalValue = (Array.isArray(originalValue) ? originalValue.join('') : String(originalValue));
                                const displayTranslatedValue = (Array.isArray(translatedValue) ? translatedValue.join('') : String(translatedValue));
                                
                                const finalTranslatedValue = displayTranslatedValue || displayOriginalValue;
                                
                                return `
                                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                        <div class="flex justify-between items-center mb-2">
                                            <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="تمت الترجمة"></span></h5>
                                            <div class="flex gap-2">
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">نسخ الأصلي</button>
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('${diffId}').parentNode.classList.toggle('hidden')">عرض/إخفاء الفروقات</button>
                                            </div>
                                        </div>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                                <div class="original-text-readonly p-3 rounded-lg text-sm h-full" style="background-color: var(--bg-color); overflow:auto;">
                                                    <div dir="auto">${this.renderContentWithMath(displayOriginalValue)}</div>
                                                </div>
                                            </div>
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                                <div id="${fieldId}" 
                                                     contenteditable="true"
                                                     class="editable-preview-field"
                                                     data-path="${path}"
                                                     data-file-index="${fileIndex}">
                                                     ${this.renderContentWithMath(finalTranslatedValue)}
                                                </div>
                                            </div>
                                        </div>
                                        <div class="mt-4 hidden">
                                             <p class="text-sm font-semibold mb-1" style="color: var (--secondary-text);">مقارنة الفروقات</p>
                                            <div id="${diffId}" class="diff-view"></div>
                                        </div>
                                    </div>`;
                            } catch (fieldError) {
                                console.warn('Error rendering field:', fieldError);
                                return '';
                            }
                        };
                
                        html += renderField('البيان (Statement)', TranslatorApp.state.originalJsonData[fileIndex].data.statement, data.statement, 'statement');
                
                        data.parts?.forEach((part, partIndex) => {
                            try {
                                const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                                if (!originalPart) return;
                
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--secondary-text);">الجزء ${partIndex + 1} (النوع: ${part.type || 'غير محدد'})</h5>`;
                
                                html += renderField('السؤال (Stem)', originalPart.stem, part.stem, `parts.${partIndex}.stem`);
                
                                if (originalPart.answer) {
                                    if (part.type === 'input_box' && typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const originalUnit = originalPart.answer.unit || '';
                                        const translatedValue = part.answer.value;
                                        const translatedUnit = part.answer.unit || '';
                                        html += this.renderInputField('الإجابة (Answer)', originalValue, translatedValue, originalUnit, translatedUnit, `parts.${partIndex}.answer.value`, fileIndex);
                                    } else if (Array.isArray(originalPart.answer)) {
                                        html += renderField('الإجابة (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'string') {
                                        html += renderField('الإجابة (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const translatedValue = (part.answer && part.answer.value) || originalPart.answer.value;
                                        html += renderField('الإجابة (Answer)', originalValue, translatedValue, `parts.${partIndex}.answer.value`);
                                    } else {
                                        html += this.renderReadOnlyField('الإجابة (Answer - غير قابلة للترجمة)', JSON.stringify(originalPart.answer));
                                    }
                                }
                
                                part.choices?.forEach((choice, choiceIndex) => {
                                    const originalChoice = originalPart.choices[choiceIndex];
                                    html += renderField(`خيار ${choiceIndex + 1}`, originalChoice.html_content, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`);
                                });
                
                                if (originalPart.gap_text_keys) {
                                    const sortedOriginalKeys = [...originalPart.gap_text_keys].sort((a, b) => a.correct_order - b.correct_order);
                                    const translatedPart = data.parts[partIndex];
                                    const sortedTranslatedKeys = [...(translatedPart.gap_text_keys || [])].sort((a, b) => a.correct_order - b.correct_order);
                
                                    sortedOriginalKeys.forEach((originalKeyItem, index) => {
                                        const translatedKeyItem = sortedTranslatedKeys[index] || { value: '' };
                                        const path = `parts.${partIndex}.gap_text_keys.${originalPart.gap_text_keys.findIndex(item => item.value === originalKeyItem.value)}.value`;
                
                                        html += `<div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                            <div class="flex justify-between items-center mb-2">
                                                <h5 class="font-bold flex items-center">كلمة الفراغ ${originalKeyItem.correct_order}</h5>
                                            </div>
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                                    <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(originalKeyItem.value)}</div>
                                                </div>
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                                    <div id="field-${fileIndex}-${path.replace(/\./g, '-')}"
                                                        contenteditable="true"
                                                        class="editable-preview-field"
                                                        data-path="${path}"
                                                        data-file-index="${fileIndex}"
                                                        dir="rtl">
                                                        ${TranslatorApp.security.sanitize(translatedKeyItem.value)}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>`;
                                    });
                                }
                
                                html += '</div>';
                            } catch (partError) {
                                console.warn('Error rendering part:', partError);
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--error-color);">خطأ في عرض الجزء ${partIndex + 1}</h5>`;
                                html += '</div>';
                            }
                        });
                
                        html += '</div>';
                        return html;
                    } catch (error) {
                        console.error('Render file content error:', error);
                        return '<div class="space-y-6"><div class="border rounded-lg p-4" style="border-color: var(--card-border);"><h5 class="font-bold flex items-center mb-2" style="color: var(--error-color);">خطأ في عرض المحتوى</h5><div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">فشل في عرض محتوى الملف</div></div></div>';
                    }
                },
                updateData(fileIndex, path, value) {
                    try {
                        const keys = path.split('.');
                        let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        const original = TranslatorApp.state.originalJsonData[fileIndex].data; // Keep original for reference
                        for (let i = 0; i < keys.length - 1; i++) {
                            current = current[keys[i]];
                        }
                        const lastKey = keys[keys.length - 1];
                
                        // Correctly handle the case for gap_text_keys
                        if (keys[keys.length - 2] === 'gap_text_keys') {
                            const keyIndex = parseInt(keys[keys.length - 1], 10);
                            if (current.gap_text_keys && current.gap_text_keys[keyIndex]) {
                                current.gap_text_keys[keyIndex].value = value;
                            }
                        } else {
                            // Otherwise, set the value directly
                            current[lastKey] = value;
                        }
                
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Update data error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث البيانات.', 'error');
                    }
                },

                generateInitialDiffs(fileIndex) {
                    try {
                        const originalData = TranslatorApp.state.originalJsonData[fileIndex].data;
                        const processPath = (path) => {
                            try {
                                if (originalData === undefined || originalData === null) return;
                                this.updateDiff(fileIndex, path);
                            } catch (error) {
                                console.warn(`Error processing path ${path}:`, error);
                            }
                        };
                        processPath('statement');
                        originalData.parts?.forEach((part, partIndex) => {
                            processPath(`parts.${partIndex}.stem`);
                            if (typeof part.answer === 'string') processPath(`parts.${partIndex}.answer`);
                            part.choices?.forEach((choice, choiceIndex) => {
                                processPath(`parts.${partIndex}.choices.${choiceIndex}.html_content`);
                            });
                            part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                                processPath(`parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                            });
                        });
                    } catch (error) {
                        console.error('Generate initial diffs error:', error);
                    }
                },

                updateDiff(fileIndex, path) {
                    try {
                        const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                        const diffId = `diff-${fieldId}`;
                        const diffContainer = document.getElementById(diffId);
                        if (!diffContainer) return;

                        const keys = path.split('.');
                        let originalText = TranslatorApp.state.originalJsonData[fileIndex].data;
                        let translatedText = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        for (let i = 0; i < keys.length; i++) {
                            originalText = originalText ? originalText[keys[i]] : '';
                            translatedText = translatedText ? translatedText[keys[i]] : '';
                        }

                        const cleanOriginal = this.plainTextForDiff(originalText || '');
                        const cleanTranslated = this.plainTextForDiff(translatedText || '');

                        diffContainer.innerHTML = this.createDiffHtml(cleanOriginal, cleanTranslated);
                    } catch (error) {
                        console.error('Update diff error:', error);
                    }
                },

                prepareInteractiveMathFields() {
                    try {
                        const mathFields = TranslatorApp.dom.previewContainer.querySelectorAll('math-field');
                        mathFields.forEach(mf => {
                            try {
                                mf.removeAttribute('read-only');
                                mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                mf.setAttribute('use-shared-virtual-keyboard', '');

                                // Enhanced language support for MathLive
                                mf.setAttribute('virtual-keyboard-layout', 'qwerty');
                                mf.setAttribute('virtual-keyboard-theme', 'material');

                                // Enable Arabic and English input
                                mf.setAttribute('virtual-keyboard-languages', 'ar,en');
                                mf.setAttribute('virtual-keyboard-default-language', 'ar');

                                // Set direction based on content
                                const currentValue = mf.value || '';
                                const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(currentValue);
                                const direction = hasArabic ? 'rtl' : 'ltr';
                                mf.setAttribute('dir', direction);

                                // Add language toggle functionality
                                mf.addEventListener('keydown', (e) => {
                                    try {
                                        // Alt + L to toggle language
                                        if (e.altKey && e.key === 'l') {
                                            e.preventDefault();
                                            const currentLang = mf.getAttribute('virtual-keyboard-default-language');
                                            const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                            mf.setAttribute('virtual-keyboard-default-language', newLang);

                                            // Update direction
                                            mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');

                                            // Show feedback
                                            const langText = newLang === 'ar' ? 'العربية' : 'English';
                                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText}`, 'info', 1500);
                                        }
                                    } catch (langError) {
                                        console.warn('Language toggle error:', langError);
                                    }
                                });

                                mf.addEventListener('focus', () => {
                                    try {
                                        if (typeof mf.executeCommand === 'function') {
                                            setTimeout(() => {
                                                try {
                                                    mf.executeCommand('showVirtualKeyboard');

                                                    // Set initial language based on content
                                                    const value = mf.value || '';
                                                    const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                                    if (hasArabic) {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                                        mf.setAttribute('dir', 'rtl');
                                                    } else {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'en');
                                                        mf.setAttribute('dir', 'ltr');
                                                    }
                                                } catch (keyboardError) {
                                                    console.warn('MathLive keyboard error:', keyboardError);
                                                }
                                            }, 100);
                                        }
                                    } catch (focusError) {
                                        console.warn('MathLive focus error:', focusError);
                                    }
                                }, { once: false });

                                // Add input event to detect language changes
                                mf.addEventListener('input', (e) => {
                                    try {
                                        const value = e.target.value || '';
                                        const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                        const hasEnglish = /[a-zA-Z]/.test(value);

                                        // Auto-switch language based on input
                                        if (hasArabic && !hasEnglish) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                            mf.setAttribute('dir', 'rtl');
                                        } else if (hasEnglish && !hasArabic) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'en');
                                            mf.setAttribute('dir', 'ltr');
                                        }
                                        // For mixed content, keep current setting
                                    } catch (inputError) {
                                        console.warn('MathLive input error:', inputError);
                                    }
                                });

                            } catch (fieldError) {
                                console.warn('MathLive field setup error:', fieldError);
                            }
                        });
                    } catch (generalError) {
                        console.warn('MathLive general setup error:', generalError);
                    }
                },

                createDiffHtml(text1, text2) {
                    try {
                        const d = this.dmp.diff_main(text1, text2);
                        this.dmp.diff_cleanupSemantic(d);
                        return this.dmp.diff_prettyHtml(d);
                    } catch (error) {
                        console.error('Create diff HTML error:', error);
                        return `<div style="color: var (--error-color);">فشل في إنشاء مقارنة الفروقات</div>`;
                    }
                },

                plainTextForDiff(html) {
                    try {
                        const div = document.createElement('div');
                        div.innerHTML = html || '';
                        return div.textContent || div.innerText || '';
                    } catch (error) {
                        console.error('Plain text for diff error:', error);
                        return '';
                    }
                },

                copyOriginalText(button) {
                    try {
                        const fieldContainer = button.closest('.border').querySelector('.original-text-readonly');
                        if (fieldContainer) {
                            const textToCopy = fieldContainer.innerHTML;
                            const textArea = document.createElement('textarea');
                            textArea.value = textToCopy;

                            textArea.style.position = 'fixed';
                            textArea.style.top = '0';
                            textArea.style.left = '0';
                            textArea.style.width = '2em';
                            textArea.style.height = '2em';
                            textArea.style.padding = '0';
                            textArea.style.border = 'none';
                            textArea.style.outline = 'none';
                            textArea.style.boxShadow = 'none';
                            textArea.style.background = 'transparent';

                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();

                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    TranslatorApp.ui.showAlert('تم نسخ النص الأصلي!', 'success', 2000);
                                } else {
                                    TranslatorApp.ui.showAlert('فشل نسخ النص.', 'error', 2000);
                                }
                            } catch (err) {
                                console.error('Fallback: Oops, unable to copy', err);
                                TranslatorApp.ui.showAlert('فشل نسخ النص.', 'error', 2000);
                            }

                            document.body.removeChild(textArea);
                        } else {
                            TranslatorApp.ui.showAlert('لم يتم العثور على النص المراد نسخه.', 'error', 2000);
                        }
                    } catch (error) {
                        console.error('Copy original text error:', error);
                        TranslatorApp.ui.showAlert('فشل في نسخ النص الأصلي.', 'error', 2000);
                    }
                },

                filter() {
                    try {
                        const term = TranslatorApp.dom.searchPreview.value.toLowerCase();
                        const accordions = document.querySelectorAll('#previewContainer > div');
                        accordions.forEach(accordion => {
                            try {
                                const content = accordion.textContent.toLowerCase();
                                const isVisible = content.includes(term);
                                accordion.style.display = isVisible ? '' : 'none';
                            } catch (error) {
                                console.warn('Error filtering accordion:', error);
                            }
                        });
                    } catch (error) {
                        console.error('Filter error:', error);
                    }
                }
            },
            export: {
                exportAs(format) {
                    return (format === 'csv') ? this.toCsv() : this.toJson();
                },

                async toJson() {
                    const useMappedIds = TranslatorApp.dom.useMappedIdsCheckbox.checked;
                    let mappedIds = [];
                    let idCounter = 0;
                    
                    if (useMappedIds) {
                        try {
                            mappedIds = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            if (!Array.isArray(mappedIds)) throw new Error('not array');
                        } catch (e) {
                            return TranslatorApp.ui.showAlert('قائمة المعرفات (mapped_id) غير صالحة. يرجى التأكد من أنها مصفوفة JSON صحيحة.', 'error');
                        }
                    }
                    
                    const selectedTranslator = TranslatorApp.state.selectedTranslator;
                    const sourceId = TranslatorApp.state.translators[selectedTranslator];
                    
                    const zip = new JSZip();
                    
                    for (const translatedFile of TranslatorApp.state.translatedJsonData) {
                        const finalData = JSON.parse(JSON.stringify(translatedFile.data));
                        const originalId = TranslatorApp.state.originalJsonData.find(f => f.name === translatedFile.name)?.data?.id;
                    
                        finalData.metadata = finalData.metadata || {};
                        finalData.metadata.title = "";
                        finalData.metadata.language = 'ar';
                        finalData.metadata.dialect = ['modern_standard'];
                        finalData.metadata.country = 'eg';
                    
                        if (sourceId) {
                            finalData.metadata.source_id = {
                                "value": parseInt(sourceId),
                                "page_number": null
                            };
                        } else {
                            finalData.metadata.source_id = null;
                        }
                    
                        const stripHtml = (html) => {
                            if (!html) return "";
                            const doc = new DOMParser().parseFromString(html, 'text/html');
                            return doc.body.textContent || "";
                        };
                    
                        const cleanStatement = stripHtml(finalData.statement);
                        const cleanStem = finalData.parts?.[0]?.stem ? stripHtml(finalData.parts[0].stem) : '';
                        let description = (cleanStatement + ' ' + cleanStem).trim();
                        finalData.metadata.description = description;
                    
                        if (finalData.parts) {
                            finalData.parts.forEach((part) => {
                                if (part.type === 'input_box' && part.answer && part.answer.hasOwnProperty('value')) {
                                    const originalUnit = TranslatorApp.state.originalJsonData
                                        .find(f => f.name === translatedFile.name)?.data.parts
                                        .find(p => p.n === part.n)?.answer.unit || '';
                                    part.answer.unit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                }
                            });
                        }
                    
                        let fileNameToUse = translatedFile.name;
                        // Assign the mapped ID for both export and display
                        if (useMappedIds && idCounter < mappedIds.length) {
                            const newMappedId = mappedIds[idCounter];
                            finalData.metadata.mapped_id = newMappedId;
                            fileNameToUse = `${newMappedId}.json`;
                            idCounter++;
                        } else {
                            finalData.metadata.mapped_id = originalId; // Fallback to original ID for the mapped_id field
                        }
                    
                        zip.file(fileNameToUse, JSON.stringify(finalData, null, 2));
                    }
                    
                    if (useMappedIds && idCounter < TranslatorApp.state.translatedJsonData.length) {
                        TranslatorApp.ui.showAlert(`تحذير: عدد المعرفات (${idCounter}) أقل من عدد الملفات (${TranslatorApp.state.translatedJsonData.length}).`, 'error');
                    }
                    
                    try {
                        const content = await zip.generateAsync({ type: "blob" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = `translated_questions_${new Date().toISOString().replace(/[:.]/g, '-')}.zip`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        TranslatorApp.ui.showAlert('تم إنشاء ملف ZIP بنجاح!', 'success');
                    } catch (e) {
                        console.error('ZIP creation error:', e);
                        TranslatorApp.ui.showAlert(`فشل إنشاء ملف ZIP: ${e.message}`, 'error');
                    }
                },
                async toCsv() {
                    let csv = '\uFEFFFileName,PartIndex,Type,OriginalText,TranslatedText\r\n';
                    TranslatorApp.state.originalJsonData.forEach((originalFile, fileIndex) => {
                        const translatedFile = TranslatorApp.state.translatedJsonData[fileIndex];
                        const fileName = originalFile.name;
                        const addRow = (partIndex, type, originalText, translatedText) => {
                            const escape = (str) => { const div = document.createElement('div'); div.innerHTML = str || ''; const text = (div.textContent || div.innerText || '').replace(/"/g, '""'); return `"${text}"`; };
                            csv += [fileName, partIndex, type, escape(originalText), escape(translatedText)].join(',') + '\r\n';
                        };
                        addRow(0, 'statement', originalFile.data.statement, translatedFile.data.statement);
                        originalFile.data.parts.forEach((part, partIndex) => {
                            const translatedPart = translatedFile.data.parts[partIndex];
                            addRow(partIndex + 1, 'stem', part.stem, translatedPart.stem);
                            if (typeof part.answer === 'string') {
                                addRow(partIndex + 1, 'answer', part.answer, translatedPart.answer);
                            } else if (part.answer && typeof part.answer === 'object' && part.answer.hasOwnProperty('value')) {
                                addRow(partIndex + 1, 'answer', part.answer.value, translatedPart.answer.value);
                            }
                            part.choices.forEach((choice, choiceIndex) => {
                                addRow(partIndex + 1, `choice_${choiceIndex + 1}`, choice.html_content, translatedPart.choices[choiceIndex].html_content);
                            });
                            part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                                addRow(partIndex + 1, `gap_text_key_${keyIndex + 1}`, keyItem.value, translatedPart.gap_text_keys[keyIndex].value);
                            });
                        });
                    });

                    try {
                        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement("a");
                        link.href = url;
                        link.download = `translated_data_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        TranslatorApp.ui.showAlert('تم إنشاء ملف CSV بنجاح!', 'success');
                    } catch (e) {
                        console.error('CSV creation error:', e);
                        TranslatorApp.ui.showAlert(`فشل إنشاء ملف CSV: ${e.message}`, 'error');
                    }
                }, // This closes the toCsv method
                annotator: {
                    canvas: null,
                    fabricCanvas: null,
                    currentImage: null,
                    open() {
                        try {
                            const images = TranslatorApp.dom.previewContainer.querySelectorAll('img');
                            if (!images.length) {
                                TranslatorApp.ui.showAlert('لا توجد صور في الصفحة الحالية.', 'info');
                                return;
                            }

                            // Use the first image in view for simplicity
                            this.currentImage = images[0];
                            if (!this.currentImage || !this.currentImage.src) {
                                TranslatorApp.ui.showAlert('الصورة المحددة غير صالحة.', 'error');
                                return;
                            }

                            TranslatorApp.ui.showModal('imageAnnotatorModal', true);
                            setTimeout(() => this.initCanvas(), 0);
                        } catch (error) {
                            console.error('Image annotator open error:', error);
                            TranslatorApp.ui.showAlert(`فشل في فتح محرر الصور: ${error.message}`, 'error');
                        }
                    },
                    close() {
                        try {
                            // Clean up Fabric.js canvas
                            if (this.fabricCanvas) {
                                this.fabricCanvas.dispose();
                                this.fabricCanvas = null;
                            }
                            this.currentImage = null;
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        } catch (error) {
                            console.error('Image annotator close error:', error);
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        }
                    },
                    initCanvas() {
                        try {
                            const canvasEl = TranslatorApp.dom.imageAnnotatorCanvas;
                            const img = this.currentImage;
                            if (!canvasEl || !img) {
                                TranslatorApp.ui.showAlert('عناصر Canvas أو الصورة غير متوفرة.', 'error');
                                return;
                            }

                            // Set canvas dimensions
                            canvasEl.width = img.naturalWidth || img.width || 800;
                            canvasEl.height = img.naturalHeight || img.height || 600;

                            // Initialize Fabric.js canvas
                            this.fabricCanvas = new fabric.Canvas(canvasEl, { selection: true });

                            // Load image into canvas
                            fabric.Image.fromURL(img.src, (oImg) => {
                                try {
                                    oImg.selectable = false;
                                    oImg.evented = false;
                                    oImg.scaleToWidth(canvasEl.width);
                                    this.fabricCanvas.add(oImg).sendToBack(oImg);
                                } catch (imgError) {
                                    console.error('Image loading error:', imgError);
                                    TranslatorApp.ui.showAlert('فشل في تحميل الصورة إلى المحرر.', 'error');
                                }
                            }, { crossOrigin: 'anonymous' });

                            // Add helper text tool with RTL support
                            this.fabricCanvas.on('mouse:dblclick', (e) => {
                                try {
                                    const pointer = this.fabricCanvas.getPointer(e.e);
                                    const textbox = new fabric.Textbox('نص', {
                                        left: pointer.x,
                                        top: pointer.y,
                                        fontSize: 24,
                                        fill: '#111827',
                                        backgroundColor: 'rgba(255,255,255,0.7)'
                                    });
                                    this.fabricCanvas.add(textbox).setActiveObject(textbox);
                                } catch (textError) {
                                    console.error('Text tool error:', textError);
                                }
                            });
                        } catch (error) {
                            console.error('Canvas initialization error:', error);
                            TranslatorApp.ui.showAlert(`فشل في تهيئة محرر الصور: ${error.message}`, 'error');
                        }
                    },
                    save() {
                        if (!this.fabricCanvas) {
                            TranslatorApp.ui.showAlert('لا يوجد محتوى للحفظ.', 'error');
                            return;
                        }

                        try {
                            const dataUrl = this.fabricCanvas.toDataURL({ format: 'png', quality: 1 });
                            if (!dataUrl || dataUrl === 'data:,') {
                                throw new Error('فشل في إنشاء صورة البيانات');
                            }

                            // Replace the image in preview with annotated version (non-destructive – just in UI)
                            this.currentImage.src = dataUrl;
                            TranslatorApp.state.hasUnsavedChanges = true;
                            this.close();
                            TranslatorApp.ui.showAlert('تم حفظ التعديلات على الصورة (محلياً).', 'success');
                        } catch (error) {
                            console.error('Image save error:', error);
                            TranslatorApp.ui.showAlert(`فشل في حفظ الصورة: ${error.message}`, 'error');
                        }
                    }
                }
            }
        }


        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());

    </script>



    <script>
        // هذه الدالة تقوم بإنشاء زر تبديل اللغة وإضافته إلى لوحة المفاتيح
        function addLanguageToggleButton() {
            // ابحث عن لوحة المفاتيح في الصفحة
            const keyboard = document.querySelector('.ML__keyboard');

            // إذا لم تكن لوحة المفاتيح موجودة، أو كان الزر موجودًا بالفعل، لا تفعل شيئًا
            if (!keyboard || keyboard.querySelector('.lang-toggle-btn')) {
                return;
            }

            // قم بإنشاء عنصر الزر الجديد
            const btn = document.createElement('button');

            // النص الذي سيظهر على الزر
            btn.textContent = 'عربي / EN';

            // كلاس CSS لتمييز الزر
            btn.className = 'lang-toggle-btn';

            // تصميم بسيط للزر ليتناسب مع لوحة المفاتيح
            btn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 170px; /* تم تعديل الموضع ليكون مناسبًا */
            padding: 5px 10px;
            font-size: 14px;
            font-weight: bold;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
        `;

            // عند النقر على الزر، قم بتنفيذ نفس الدالة التي كان الاختصار ينفذها
            btn.onclick = () => TranslatorApp.utils.mathLive.toggleLanguage();

            // أضف الزر الجديد إلى لوحة المفاتيح
            keyboard.appendChild(btn);
        }

        // بما أن لوحة المفاتيح تظهر وتختفي، سنقوم بتشغيل الدالة بشكل دوري
        // للتحقق من ظهورها وإضافة الزر كل نصف ثانية
        setInterval(addLanguageToggleButton, 500);
    </script>
</body>

</html>
